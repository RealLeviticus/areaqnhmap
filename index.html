<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Area QNH Map</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.5.2/dist/maplibre-gl.css" />
  <style>
    :root {
      --panel: #f7f7f7;
      --stroke: #d6d6d6;
      --label-red: #c40000;
    }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: #ffffff;
      color: #111;
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
    }
    header {
      padding: 14px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--panel);
      border-bottom: 1px solid var(--stroke);
      gap: 8px;
      flex-wrap: wrap;
    }
    .title h1 { margin: 0; font-size: 1.1rem; }
    .title .sub { margin: 0; font-size: 0.9rem; color: #555; }
    #validity {
      margin-left: auto;
      font-size: 0.9rem;
      color: #444;
      white-space: nowrap;
    }
    main { padding: 16px; }
    #map {
      width: 100%;
      height: 72vh;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.18);
      background: #edf1f5;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Area QNH Map</h1>
      <p class="sub">Replicate of the BOM Area QNH Map removed from the new BOM website.</p>
    </div>
    <div id="validity">Fetching QNH…</div>
  </header>

  <main>
    <div id="map" aria-label="Area QNH map"></div>
  </main>

  <script src="https://unpkg.com/maplibre-gl@3.5.2/dist/maplibre-gl.js"></script>
  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        glyphs: 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
        sources: {
          osm: {
            type: 'raster',
            tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [{ id: 'osm-base', type: 'raster', source: 'osm' }]
      },
      center: [134.5, -25.5],
      zoom: 3.6
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-left');

    const AREA_DATA_URL = 'data/gaf-areas.geojson';
    const QNH_WORKER_URL = 'https://areaqnh.therealleviticus.workers.dev/';

    let areaGeoJSON = null;
    let areaQnhMap = {};

    map.on('load', () => {
      loadAreas();
      startQNHLoop();
    });

    async function loadAreas() {
      const res = await fetch(AREA_DATA_URL);
      const geojson = await res.json();
      geojson.features.forEach((f, i) => f.id = i + 1);
      areaGeoJSON = geojson;

      map.addSource('areas', { type: 'geojson', data: geojson });

      map.addLayer({
        id: 'areas-fill',
        type: 'fill',
        source: 'areas',
        paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.30 }
      });

      map.addLayer({
        id: 'areas-line',
        type: 'line',
        source: 'areas',
        paint: { 'line-color': '#d40000', 'line-width': 2 }
      });

      // QNH label (black) above
      map.addLayer({
        id: 'areas-qnh',
        type: 'symbol',
        source: 'areas',
        layout: {
          'text-field': ['to-string', ['coalesce', ['get', 'qnh'], '']],
          'text-font': ['Open Sans Regular'],
          'text-size': 18,
          'text-allow-overlap': true,
          'text-ignore-placement': true,
          'text-variable-anchor': ['center'],
          'text-offset': [0, -0.9],
          'symbol-z-order': 'source'
        },
        paint: {
          'text-color': '#000',
          'text-halo-color': '#fff',
          'text-halo-width': 1.4
        }
      });

      // Area label (red) below
      map.addLayer({
        id: 'areas-name',
        type: 'symbol',
        source: 'areas',
        layout: {
          'text-field': ['concat', 'AREA ', ['slice', ['get', 'area_code'], 5]],
          'text-font': ['Open Sans Regular'],
          'text-size': 11,
          'text-allow-overlap': true,
          'text-ignore-placement': true,
          'text-variable-anchor': ['center'],
          'text-offset': [0, 1.0],
          'symbol-z-order': 'source'
        },
        paint: {
          'text-color': '#c40000',
          'text-halo-color': '#fff',
          'text-halo-width': 1.0
        }
      });

      applyAreaQnhToPolygons();
      fitToAreas(geojson);
    }

    function startQNHLoop() {
      fetchAndDrawQNH();
      setInterval(fetchAndDrawQNH, 15 * 60 * 1000);
    }

    async function fetchAndDrawQNH() {
      const validityBox = document.getElementById('validity');
      try {
        const res = await fetch(QNH_WORKER_URL + '?t=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.text();

        // --- CLEAN: keep line breaks, strip tags/scripts/styles, decode entities
        let text = raw
          .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
          .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
          .replace(/<br\s*\/?>/gi, '\n')
          .replace(/<\/(p|div|li|h\d|section)>/gi, '\n')
          .replace(/<[^>]+>/g, ' ')           // tags -> space (not newline)
          .replace(/&nbsp;/g, ' ')
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          // normalise whitespace but PRESERVE newlines:
          .replace(/[ \t]+\n/g, '\n')
          .replace(/\n[ \t]+/g, '\n')
          .replace(/\n{3,}/g, '\n\n')
          .trim();

        const parsed = parseQNHText(text);
        areaQnhMap = parsed.areaQnhMap;
        applyAreaQnhToPolygons();

        // Compact validity header
        const v = parsed.validIssued;
        validityBox.textContent = v ? `Valid: ${v.valid} · Issued: ${v.issued}` : 'Validity unknown';
      } catch (err) {
        console.error('Failed to fetch/parse QNH', err);
        document.getElementById('validity').textContent = 'Failed to fetch QNH';
      }
    }

    function parseQNHText(text) {
      // Split into real lines (we preserved newlines above)
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

      // Build blocks: "Area XX:" until the next "Area" or EOF or "Valid:"
      const blocks = [];
      let current = null;
      for (const line of lines) {
        const m = line.match(/^(?:AREA|Area)\s*(\d+)\s*:/);
        if (m) {
          if (current) blocks.push(current);
          current = { area: `AREA-${m[1]}`, lines: [] };
          continue;
        }
        if (/^Valid:/i.test(line) && current) {
          blocks.push(current);
          current = null;
          // do not break; keep scanning to harvest later Valid/Issued occurrences
          continue;
        }
        if (current) current.lines.push(line);
      }
      if (current) blocks.push(current);

      // Last 4-digit number per block is the QNH
      const areaQnhMapLocal = {};
      for (const b of blocks) {
        const txt = b.lines.join(' ');
        const q = txt.match(/(\d{4})(?!.*\d{4})/);
        const qnh = q ? Number(q[1]) : null;
        if (qnh && qnh >= 900 && qnh <= 1050) {
          areaQnhMapLocal[b.area] = { qnh };
        }
      }

      // Pull the last Valid / Issued in the entire text (there are several)
      const validAll = [...text.matchAll(/Valid:\s*([^\n]*?)(?=Issued:|\n|$)/gi)];
      const issuedAll = [...text.matchAll(/Issued:\s*([^\n]*)/gi)];
      const validIssued = (validAll.length && issuedAll.length)
        ? { valid: validAll.at(-1)[1].trim(), issued: issuedAll.at(-1)[1].trim() }
        : null;

      return { areaQnhMap: areaQnhMapLocal, validIssued };
    }

    function applyAreaQnhToPolygons() {
      if (!areaGeoJSON) return;
      let count = 0;
      areaGeoJSON.features.forEach(f => {
        const code = f.properties?.area_code?.toUpperCase();
        const match = areaQnhMap[code];
        if (match) {
          f.properties.qnh = match.qnh;
          count++;
        } else {
          delete f.properties.qnh;
        }
      });
      if (map.getSource('areas')) map.getSource('areas').setData(areaGeoJSON);
      console.log('Applied QNH to', count, 'areas');
    }

    function fitToAreas(geojson) {
      const bounds = getGeoJsonBounds(geojson);
      if (bounds) map.fitBounds(bounds, { padding: 40, maxZoom: 6 });
    }

    function getGeoJsonBounds(geojson) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      const update = ([x, y]) => {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
        if (x < -180 || x > 180 || y < -90 || y > 90) return;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      };
      const walk = coords => {
        if (!Array.isArray(coords)) return;
        if (typeof coords[0] === 'number') update(coords);
        else coords.forEach(walk);
      };
      if (!geojson?.features) return null;
      geojson.features.forEach(f => f.geometry?.coordinates && walk(f.geometry.coordinates));
      if (!Number.isFinite(minX)) return null;
      return [[minX, minY], [maxX, maxY]];
    }
  </script>
</body>
</html>
