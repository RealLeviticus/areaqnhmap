<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Area QNH Map</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    :root {
      /* Light BOM-ish look */
      --bg: #ffffff;
      --card-bg: #ffffff;
      --border: #d0d0d0;
      --text: #111111;
      --text-muted: #666666;
      --accent: #1f6feb;

      --success: #2ea043;
      --error: #d1242f;
      --warning: #bf8700;

      --area-color: #ff0000;
      --split-color: #1a8f2a;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: "Segoe UI", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    header {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 12px 20px;
      flex-shrink: 0;
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
    }

    h1 {
      font-size: 1.4rem;
      font-weight: 600;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.85rem;
      margin-top: 2px;
    }

    #validity {
      font-size: 0.85rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      animation: pulse 2s infinite;
    }

    .status-dot.loading {
      background: var(--warning);
    }

    .status-dot.error {
      background: var(--error);
      animation: none;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .nav-links a {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.9rem;
      padding: 6px 12px;
      border: 1px solid var(--accent);
      border-radius: 6px;
      transition: all 0.2s;
      background: #fff;
    }

    .nav-links a:hover {
      background: var(--accent);
      color: #fff;
    }

    #map {
      flex: 1;
      width: 100%;
    }

    /* Make MapLibre UI match light theme */
    .maplibregl-ctrl-attrib {
      background: rgba(255, 255, 255, 0.9) !important;
      color: var(--text-muted) !important;
      border: 1px solid var(--border) !important;
      border-radius: 6px !important;
    }

    .maplibregl-ctrl-attrib a {
      color: var(--accent) !important;
    }

    .maplibregl-ctrl-group {
      background: rgba(255, 255, 255, 0.95) !important;
      border: 1px solid var(--border) !important;
      border-radius: 6px !important;
      overflow: hidden;
    }

    .maplibregl-ctrl-group button {
      background-color: transparent !important;
    }

    .maplibregl-ctrl-group button:hover {
      background-color: rgba(0, 0, 0, 0.05) !important;
    }

    .maplibregl-ctrl-group button span {
      filter: none;
    }

    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        align-items: flex-start;
      }

      header {
        padding: 10px 12px;
      }
    }

    /* Debug panel styles */
    #debugPanel {
      position: fixed;
      bottom: 60px;
      left: 10px;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      max-width: 350px;
      max-height: 70vh;
      overflow-y: auto;
      font-size: 0.75rem;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      display: none;
    }

    #debugPanel.visible {
      display: block;
    }

    #debugPanel h3 {
      font-size: 0.85rem;
      margin-bottom: 8px;
      color: var(--text);
      border-bottom: 1px solid var(--border);
      padding-bottom: 4px;
    }

    #debugPanel .stat {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
      padding: 2px 0;
    }

    #debugPanel .stat-label {
      color: var(--text-muted);
    }

    #debugPanel .stat-value {
      font-weight: 600;
      color: var(--text);
    }

    #debugPanel .stat-value.good {
      color: var(--success);
    }

    #debugPanel .stat-value.warn {
      color: var(--warning);
    }

    #debugPanel .stat-value.bad {
      color: var(--error);
    }

    #debugPanel .area-validation {
      margin: 8px 0;
      padding: 6px;
      background: #f6f8fa;
      border-radius: 4px;
      font-size: 0.7rem;
    }

    #debugPanel .area-validation.has-issues {
      background: #fff3cd;
      border-left: 3px solid var(--warning);
    }

    #debugBtn {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 1.2rem;
      z-index: 1000;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #debugBtn:hover {
      background: var(--accent);
      color: white;
      transform: scale(1.05);
    }

    #debugBtn.active {
      background: var(--accent);
      color: white;
    }

    #debugPanel .area-controls {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    #debugPanel .area-controls button {
      padding: 2px 6px;
      font-size: 0.65rem;
      border: 1px solid var(--border);
      background: white;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    #debugPanel .area-controls button:hover {
      background: #f0f0f0;
    }

    #debugPanel .area-controls button.active {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }
  </style>
</head>

<body>
  <header>
    <div class="header-content">
      <div>
        <h1>Area QNH Map</h1>
        <p class="subtitle">Australian aviation altimeter setting regions</p>
      </div>
      <div id="validity">
        <span class="status-dot loading" id="statusDot"></span>
        <span id="validityText">Loading...</span>
      </div>
      <nav class="nav-links">
        <a href="static.html">Static Images ‚Üí</a>
      </nav>
    </div>
  </header>

  <div id="map">
  </div>

  <!-- Debug UI -->
  <button id="debugBtn" title="Toggle Debug Panel">üêõ</button>
  <div id="debugPanel">
    <h3>Zone Validation</h3>
    <div id="debugContent">Click to run validation...</div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
    // Screenshot mode (use: index.html?screenshot=1)
    const IS_SCREENSHOT = new URLSearchParams(location.search).get('screenshot') === '1';
    if (IS_SCREENSHOT) document.body.classList.add('screenshot');

    const $ = id => document.getElementById(id);

    const showWarning = msg => {
      if (IS_SCREENSHOT) return;
      if (msg) {
        console.warn(msg);
        $('statusDot').className = 'status-dot error';
      }
    };

    const QNH_URL = 'https://areaqnh.therealleviticus.workers.dev/';
    const NAV_URL = 'https://airspace.therealleviticus.workers.dev/';

    // Light basemap (no labels) to mimic BOM-style output
    function getMapStyle() {
      return {
        version: 8,
        glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
        sources: {
          'carto': {
            type: 'raster',
            tiles: ['https://a.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}@2x.png'],
            tileSize: 256,
            attribution: '¬© CARTO ¬© OpenStreetMap'
          }
        },
        layers: [
          { id: 'base', type: 'raster', source: 'carto' }
        ]
      };
    }

    // ====== AREAS GEOJSON (unchanged) ======
    const AREAS = { "type": "FeatureCollection", "features": [{ "type": "Feature", "properties": { "area_code": "AREA-20" }, "geometry": { "type": "Polygon", "coordinates": [[[148.383333, -32.75], [150.0, -29.0], [154.703056, -28.043611], [155.0, -28.833333], [152.666667, -34.333333], [151.177222, -33.946111], [150.988333, -33.924444], [149.651944, -33.409444], [148.383333, -32.75]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-21" }, "geometry": { "type": "Polygon", "coordinates": [[[146.924722, -36.195278], [148.383333, -32.75], [149.651944, -33.409444], [150.988333, -33.924444], [151.177222, -33.946111], [152.666667, -34.333333], [150.870556, -37.881111], [149.976111, -37.503889], [146.924722, -36.195278]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-22" }, "geometry": { "type": "Polygon", "coordinates": [[[141.0, -29.0], [150.0, -29.0], [148.383333, -32.75], [146.924722, -36.195278], [141.0, -33.65], [141.0, -29.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-24" }, "geometry": { "type": "Polygon", "coordinates": [[[152.666667, -34.333333], [155.0, -28.833333], [163.0, -28.5], [163.0, -31.333333], [152.666667, -34.333333]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-30" }, "geometry": { "type": "Polygon", "coordinates": [[[141.0, -33.65], [146.924722, -36.195278], [149.976111, -37.503889], [150.870556, -37.881111], [150.2, -39.57], [142.8575, -39.57], [141.0, -39.57], [141.0, -33.65]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-40" }, "geometry": { "type": "Polygon", "coordinates": [[[147.820833, -23.156111], [152.864444, -23.155833], [154.703056, -28.043611], [150.0, -29.0], [148.183333, -23.566667], [147.820833, -23.156111]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-41" }, "geometry": { "type": "Polygon", "coordinates": [[[138.0, -26.0], [138.0, -23.156111], [147.820833, -23.156111], [148.183333, -23.566667], [150.0, -29.0], [141.0, -29.0], [141.0, -26.0], [138.0, -26.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-43" }, "geometry": { "type": "Polygon", "coordinates": [[[138.0, -23.156111], [138.0, -19.0], [143.533333, -18.3], [147.820833, -23.156111], [138.0, -23.156111]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-44" }, "geometry": { "type": "Polygon", "coordinates": [[[143.533333, -18.3], [148.0, -18.283333], [152.864444, -23.155833], [147.820833, -23.156111], [143.533333, -18.3]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-45" }, "geometry": { "type": "Polygon", "coordinates": [[[141.0, -9.833333], [141.033333, -9.616667], [142.083333, -9.261667], [142.805, -9.323889], [143.875, -9.133333], [144.233333, -9.4], [144.089167, -9.942778], [144.026667, -11.5], [144.072222, -11.725], [144.0, -12.0], [147.607778, -16.995833], [148.0, -18.283333], [143.533333, -18.3], [138.0, -19.0], [138.0, -14.0], [141.0, -9.833333]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-50" }, "geometry": { "type": "Polygon", "coordinates": [[[134.5, -35.5], [135.372222, -34.686667], [137.716667, -32.5], [141.0, -33.65], [141.0, -39.57], [134.5, -35.5]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-51" }, "geometry": { "type": "Polygon", "coordinates": [[[135.0, -30.0], [141.0, -29.0], [141.0, -33.65], [137.716667, -32.5], [135.0, -30.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-52" }, "geometry": { "type": "Polygon", "coordinates": [[[129.0, -26.0], [138.0, -26.0], [141.0, -26.0], [141.0, -29.0], [135.0, -30.0], [129.0, -30.0], [129.0, -26.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-53" }, "geometry": { "type": "Polygon", "coordinates": [[[129.0, -30.0], [135.0, -30.0], [137.716667, -32.5], [135.372222, -34.686667], [134.5, -35.5], [131.0, -32.5], [129.0, -33.0], [129.0, -30.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-60" }, "geometry": { "type": "Polygon", "coordinates": [[[112.5, -27.5], [118.0, -27.5], [119.0, -32.25], [113.5, -33.5], [112.5, -27.5]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-61" }, "geometry": { "type": "Polygon", "coordinates": [[[119.0, -32.25], [118.0, -27.5], [123.5, -27.5], [123.618333, -30.84], [119.0, -32.25]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-62" }, "geometry": { "type": "Polygon", "coordinates": [[[123.618333, -30.84], [129.0, -30.0], [129.0, -33.0], [123.5, -35.0], [123.618333, -30.84]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-63" }, "geometry": { "type": "Polygon", "coordinates": [[[113.5, -33.5], [119.0, -32.25], [123.618333, -30.84], [123.5, -35.0], [116.0, -36.25], [113.5, -33.5]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-64" }, "geometry": { "type": "Polygon", "coordinates": [[[123.5, -23.88], [129.0, -23.88], [129.0, -30.0], [123.618333, -30.84], [123.5, -27.5], [123.5, -23.88]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-65" }, "geometry": { "type": "Polygon", "coordinates": [[[112.096944, -23.88], [115.984722, -23.88], [118.0, -27.5], [112.5, -27.5], [112.096944, -23.88]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-66" }, "geometry": { "type": "Polygon", "coordinates": [[[115.984722, -23.88], [123.5, -23.88], [123.5, -27.5], [118.0, -27.5], [115.984722, -23.88]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-68" }, "geometry": { "type": "Polygon", "coordinates": [[[112.0, -23.0], [113.0, -21.0], [117.0, -18.0], [120.0, -18.0], [123.5, -20.5], [123.5, -23.88], [115.984722, -23.88], [112.096944, -23.88], [112.0, -23.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-69" }, "geometry": { "type": "Polygon", "coordinates": [[[117.0, -18.0], [124.0, -14.0], [126.148056, -13.751667], [127.5, -14.0], [128.416667, -14.833333], [129.0, -14.879444], [129.0, -20.0], [123.5, -20.5], [120.0, -18.0], [117.0, -18.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-70" }, "geometry": { "type": "Polygon", "coordinates": [[[142.8575, -39.57], [150.2, -39.57], [149.0, -43.0], [147.5, -44.5], [145.0, -44.0], [142.8575, -39.57]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-80" }, "geometry": { "type": "Polygon", "coordinates": [[[129.0, -9.409722], [141.0, -9.833333], [138.0, -14.0], [138.0, -19.0], [129.0, -15.884444], [129.0, -14.879444], [129.0, -9.409722]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-83" }, "geometry": { "type": "Polygon", "coordinates": [[[123.5, -20.5], [129.0, -20.0], [129.0, -23.88], [123.5, -23.88], [123.5, -20.5]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-84" }, "geometry": { "type": "Polygon", "coordinates": [[[129.0, -20.0], [129.0, -15.884444], [138.0, -19.0], [138.0, -23.156111], [129.0, -22.25], [129.0, -20.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-85" }, "geometry": { "type": "Polygon", "coordinates": [[[129.0, -23.88], [129.0, -22.25], [138.0, -23.156111], [138.0, -26.0], [129.0, -26.0], [129.0, -23.88]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-86" }, "geometry": { "type": "Polygon", "coordinates": [[[124.774444, -10.9125], [126.833333, -9.333333], [129.0, -9.409722], [129.0, -14.879444], [128.416667, -14.833333], [127.5, -14.0], [126.148056, -13.751667], [124.0, -14.0], [124.774444, -10.9125]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-87" }, "geometry": { "type": "Polygon", "coordinates": [[[112.0, -18.0], [118.0, -15.0], [124.0, -14.0], [117.0, -18.0], [112.0, -18.0]]] } }, { "type": "Feature", "properties": { "area_code": "AREA-88" }, "geometry": { "type": "Polygon", "coordinates": [[[110.0, -19.0], [112.0, -18.0], [117.0, -18.0], [113.0, -21.0], [110.0, -19.0]]] } }] };

    let areaGeoJSON, areaQnhMap = {}, areaSplits = {}, navPointMap = {}, map;

    function initMap() {
      map = new maplibregl.Map({
        container: 'map',
        style: getMapStyle(),
        center: [134.5, -25.5],
        zoom: 4,
        preserveDrawingBuffer: true
      });

      // expose for puppeteer
      window.map = map;

      map.on('load', async () => {
        await loadAreas();
        await fetchNav();
        await fetchQNH();
        setInterval(fetchQNH, 300000);
      });
    }

    document.readyState === 'loading'
      ? document.addEventListener('DOMContentLoaded', initMap)
      : initMap();

    async function loadAreas() {
      areaGeoJSON = JSON.parse(JSON.stringify(AREAS));
      areaGeoJSON.features.forEach((f, i) => f.id = i + 1);

      map.addSource('areas', { type: 'geojson', data: areaGeoJSON });

      // Area boundary, red
      map.addLayer({
        id: 'areas-line',
        type: 'line',
        source: 'areas',
        paint: { 'line-color': '#ff0000', 'line-width': 2 }
      });

      updateLabels();
    }

    function pointInPoly(pt, ring) {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const [xi, yi] = ring[i], [xj, yj] = ring[j];
        if (((yi > pt[1]) !== (yj > pt[1])) && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi)) inside = !inside;
      }
      return inside;
    }

    function distToSeg(pt, a, b) {
      const dx = b[0] - a[0], dy = b[1] - a[1], l2 = dx * dx + dy * dy;
      if (l2 === 0) return Math.hypot(pt[0] - a[0], pt[1] - a[1]);
      let t = Math.max(0, Math.min(1, ((pt[0] - a[0]) * dx + (pt[1] - a[1]) * dy) / l2));
      return Math.hypot(pt[0] - (a[0] + t * dx), pt[1] - (a[1] + t * dy));
    }

    function findLabelPos(ring, grid = 50) {
      if (!ring || ring.length < 3) return [0, 0];
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      ring.forEach(([x, y]) => { minX = Math.min(minX, x); maxX = Math.max(maxX, x); minY = Math.min(minY, y); maxY = Math.max(maxY, y); });
      const sx = (maxX - minX) / grid, sy = (maxY - minY) / grid;
      let best = null, maxD = -Infinity;
      for (let i = 0; i <= grid; i++) for (let j = 0; j <= grid; j++) {
        const pt = [minX + i * sx, minY + j * sy];
        if (!pointInPoly(pt, ring)) continue;
        let minDist = Infinity;
        for (let k = 0; k < ring.length - 1; k++) minDist = Math.min(minDist, distToSeg(pt, ring[k], ring[k + 1]));
        if (minDist > maxD) { maxD = minDist; best = pt; }
      }
      return best || [
        ring.reduce((s, c) => s + c[0], 0) / (ring.length - 1),
        ring.reduce((s, c) => s + c[1], 0) / (ring.length - 1)
      ];
    }

    // If an area has splits, we do NOT include it in the main "labels" source at all.
    // Its AREA id only appears under the split QNH labels.
    function updateLabels() {
      const features = [];

      for (const f of areaGeoJSON.features) {
        const code = f.properties.area_code;
        const ring = f.geometry.coordinates[0];
        const splits = areaSplits[code];

        // If split area, remove main label entirely
        if (splits && splits.length) continue;

        const entry = areaQnhMap[code];
        const qnh = entry?.qnh ?? null;

        features.push({
          type: 'Feature',
          properties: {
            qnh,
            area_num: code.slice(5)
          },
          geometry: { type: 'Point', coordinates: findLabelPos(ring) }
        });
      }

      const fc = { type: 'FeatureCollection', features };

      if (map.getSource('labels')) map.getSource('labels').setData(fc);
      else {
        map.addSource('labels', { type: 'geojson', data: fc });

        // Black QNH + Red AREA under it, like BOM-ish styling
        map.addLayer({
          id: 'labels',
          type: 'symbol',
          source: 'labels',
          layout: {
            'text-field': [
              'format',
              ['to-string', ['coalesce', ['get', 'qnh'], '']], { 'font-scale': 1.05, 'text-color': '#000000' },
              '\n', {}, // newline
              ['concat', 'AREA ', ['get', 'area_num']], { 'font-scale': 0.75, 'text-color': '#ff0000' }
            ],
            'text-font': ['Noto Sans Regular'],
            'text-size': 16,
            'text-allow-overlap': true,
            'text-ignore-placement': true
          },
          paint: {
            'text-halo-color': '#ffffff',
            'text-halo-width': 2
          }
        });
      }
    }

    async function fetchNav() {
      try {
        const res = await fetch(NAV_URL + '?t=' + Date.now());
        if (!res.ok) return;
        const doc = new DOMParser().parseFromString(await res.text(), 'application/xml');

        doc.querySelectorAll('Point[Name]').forEach(n => {
          const c = parseCoord(n.textContent);
          if (c) navPointMap[n.getAttribute('Name').toUpperCase()] = c;
        });

        doc.querySelectorAll('Airport').forEach(n => {
          const c = parseCoord(n.getAttribute('Position') || n.textContent);
          if (c) ['ICAO', 'Name', 'FullName'].forEach(a => {
            const v = n.getAttribute(a);
            if (v) navPointMap[v.toUpperCase()] = c;
          });
        });
      } catch (e) {
        console.error(e);
      }
    }

    function parseCoord(raw) {
      if (!raw) return null;
      const p = raw.split(/(?=[+-]\d)/).filter(Boolean);
      if (p.length !== 2) return null;
      const lat = dms(p[0]), lon = dms(p[1]);
      return (isFinite(lat) && isFinite(lon)) ? [lon, lat] : null;
    }

    function dms(s) {
      if (!s) return NaN;
      const sign = s.trim().startsWith('-') ? -1 : 1;
      const n = Math.abs(parseFloat(s));
      const d = Math.floor(n / 10000);
      const r = n - d * 10000;
      const m = Math.floor(r / 100);
      return sign * (d + m / 60 + (r - m * 100) / 3600);
    }

    async function fetchQNH() {
      $('statusDot').className = 'status-dot loading';
      $('validityText').textContent = 'Fetching...';

      try {
        const res = await fetch(QNH_URL + '?t=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);

        const text = (await res.text()).replace(/<[^>]+>/g, ' ').replace(/&\w+;/g, ' ').trim();
        const parsed = parseQNH(text);

        // Extract REST QNH values and use them as main QNH
        areaQnhMap = {};
        for (const [area, entry] of Object.entries(parsed.qnhMap)) {
          let mainQNH = entry.qnh;
          
          // If this area has splits, look for the REST QNH value
          if (parsed.splits[area]) {
            const restRule = parsed.splits[area].find(r => r.type === 'rest');
            if (restRule && restRule.qnh) {
              mainQNH = restRule.qnh;
            }
          }
          
          areaQnhMap[area] = { qnh: mainQNH };
        }
        
        areaSplits = {}; // Disable splits

        updateLabels();

        const v = parsed.validity;
        $('statusDot').className = 'status-dot';
        $('validityText').textContent = v ? `Valid: ${v.valid} | Issued: ${v.issued}` : 'Data loaded';
      } catch (e) {
        console.error(e);
        $('validityText').textContent = 'Failed';
        showWarning('Failed to fetch QNH data');
      }
    }

    function parseQNH(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean), blocks = [];
      let cur = null;

      for (const line of lines) {
        const m = line.match(/^(?:AREA|Area)\s*(\d+)\s*:(.*)$/);
        if (m) {
          if (cur) blocks.push(cur);
          cur = { area: `AREA-${m[1]}`, lines: [] };
          if (m[2].trim()) cur.lines.push(m[2].trim());
          continue;
        }
        if (/^Valid:/i.test(line) && cur) { blocks.push(cur); cur = null; continue; }
        if (cur) cur.lines.push(line);
      }
      if (cur) blocks.push(cur);

      const qnhMap = {}, splits = {};

      for (const b of blocks) {
        const txt = b.lines.join(' ');
        const nums = [...txt.matchAll(/\b(\d{4})\b/g)].map(m => +m[1]);
        const qnh = nums.find(n => n >= 900 && n <= 1050);
        if (qnh) qnhMap[b.area] = { qnh };

        const rules = [];
        let m;

        const betweenRx = /BETWEEN\s+([^,]+?)\s+AND\s+([^,]+?)\s+(\d{4})(?=[^\d]|$)/gi;
        while ((m = betweenRx.exec(txt))) rules.push({ type: 'between', lhs: m[1].trim(), rhs: m[2].trim(), qnh: +m[3] });

        const ofRx = /\b(NW|NE|SW|SE|N|S|E|W)\s+OF\s+([^,]+?)\s+(\d{4})(?=[^\d]|$)/gi;
        while ((m = ofRx.exec(txt))) rules.push({ type: 'of', dir: m[1].toUpperCase(), lhs: m[2].trim(), qnh: +m[3] });

        const restRx = /\bREST\s+(\d{4})(?=[^\d]|$)/gi;
        while ((m = restRx.exec(txt))) rules.push({ type: 'rest', qnh: +m[1] });

        if (rules.length) splits[b.area] = rules;
      }

      const validM = [...text.matchAll(/Valid:\s*([^\n]*?)(?=Issued:|\n|$)/gi)];
      const issueM = [...text.matchAll(/Issued:\s*([^\n]*)/gi)];

      const validity = (validM.length && issueM.length)
        ? { valid: validM.at(-1)[1].trim(), issued: issueM.at(-1)[1].trim() }
        : null;

      return { qnhMap, splits, validity };
    }

    function resolveToken(tok) {
      if (!tok) return null;
      const t = tok.trim();
      const pats = [
        /^(\d{1,2})([NS])(\d{1,3})([EW])$/i,
        /^(\d{1,2})(\d{2})([NS])(\d{1,3})(\d{2})([EW])$/i
      ];

      for (const p of pats) {
        const m = t.match(p);
        if (m) {
          const hasMin = m.length > 5;
          const lat = (m[hasMin ? 3 : 2].toUpperCase() === 'S' ? -1 : 1) * (+m[1] + (hasMin ? +m[2] : 0) / 60);
          const lon = (m[hasMin ? 6 : 4].toUpperCase() === 'W' ? -1 : 1) * (+m[hasMin ? 4 : 3] + (hasMin ? +m[5] : 0) / 60);
          return { coord: [lon, lat], name: t.toUpperCase() };
        }
      }

      const c = navPointMap[t.toUpperCase()];
      return c ? { coord: c, name: t.toUpperCase() } : null;
    }

    function tokenize(s) {
      const skip = new Set(['N', 'S', 'E', 'W', 'NE', 'NW', 'SE', 'SW', 'OF', 'TO', 'FROM']);
      return s.split(/[\s\/]+/)
        .map(t => t.replace(/[.,;]+$/, '').trim())
        .filter(t => t && !skip.has(t.toUpperCase()));
    }

    // Signed distance from point to line segment (positive = left side, negative = right side)
    function signedDist(pt, a, b) { 
      return (b[0] - a[0]) * (pt[1] - a[1]) - (b[1] - a[1]) * (pt[0] - a[0]); 
    }

    // Determine which side of a polyline a point is on
    // Returns positive for "left" side, negative for "right" side
    // Uses closest segment to determine sidedness
    function polylineSide(pt, polyline) {
      if (!polyline || polyline.length < 2) return 0;
      
      let minDist = Infinity;
      let closestSegIdx = 0;
      
      for (let i = 0; i < polyline.length - 1; i++) {
        const d = distToSeg(pt, polyline[i], polyline[i + 1]);
        if (d < minDist) {
          minDist = d;
          closestSegIdx = i;
        }
      }
      
      return signedDist(pt, polyline[closestSegIdx], polyline[closestSegIdx + 1]);
    }

    // FIXED: Check if point is on a compass side of a polyline
    // Uses a reference point approach - find a point definitely in the compass direction
    // and check if the test point is on the same side of the line
    function onCompassSide(pt, line, dir) {
      if (!line || line.length < 2) return false;
      
      // First check: is point too close to the line? If so, exclude it (hard border)
      let minDist = Infinity;
      for (let i = 0; i < line.length - 1; i++) {
        minDist = Math.min(minDist, distToSeg(pt, line[i], line[i + 1]));
      }
      // Points within ~300m of line (0.003 degrees) are on the border - exclude
      if (minDist < 0.003) return false;

      // Map compass directions to unit vectors
      let compassX = 0, compassY = 0;
      switch(dir) {
        case 'N':  compassX = 0;      compassY = 1;     break;
        case 'S':  compassX = 0;      compassY = -1;    break;
        case 'E':  compassX = 1;      compassY = 0;     break;
        case 'W':  compassX = -1;     compassY = 0;     break;
        case 'NE': compassX = 0.707;  compassY = 0.707; break;
        case 'NW': compassX = -0.707; compassY = 0.707; break;
        case 'SE': compassX = 0.707;  compassY = -0.707;break;
        case 'SW': compassX = -0.707; compassY = -0.707;break;
      }

      // Find centroid of the line
      let cx = 0, cy = 0;
      for (const p of line) {
        cx += p[0];
        cy += p[1];
      }
      cx /= line.length;
      cy /= line.length;

      // Create a reference point far in the compass direction from the line's centroid
      const refPoint = [cx + compassX * 100, cy + compassY * 100];

      // Determine which side of the line the reference point is on
      const refSide = polylineSide(refPoint, line);
      
      // Determine which side of the line the test point is on
      const ptSide = polylineSide(pt, line);

      // Point is on the compass side if it's on the same side as the reference point
      return (ptSide > 0) === (refSide > 0);
    }

    function between(pt, l1, l2) {
      if (!l1 || l1.length < 2 || !l2 || l2.length < 2) return false;
      
      // Check if point is too close to either line (hard border)
      for (let i = 0; i < l1.length - 1; i++) {
        if (distToSeg(pt, l1[i], l1[i + 1]) < 0.003) return false;
      }
      for (let i = 0; i < l2.length - 1; i++) {
        if (distToSeg(pt, l2[i], l2[i + 1]) < 0.003) return false;
      }
      
      // Use a point from the middle of l2 as reference for "toward l2" direction
      const midIdxL2 = Math.floor(l2.length / 2);
      const refPointL2 = l2[midIdxL2];
      const l2SideOfL1 = polylineSide(refPointL2, l1);
      
      // Use a point from the middle of l1 as reference for "toward l1" direction
      const midIdxL1 = Math.floor(l1.length / 2);
      const refPointL1 = l1[midIdxL1];
      const l1SideOfL2 = polylineSide(refPointL1, l2);
      
      // Check which side our test point is on for each polyline
      const ptSideOfL1 = polylineSide(pt, l1);
      const ptSideOfL2 = polylineSide(pt, l2);
      
      // Point is between if it's on the l2-facing side of l1 AND on the l1-facing side of l2
      const onL2SideOfL1 = (ptSideOfL1 > 0) === (l2SideOfL1 > 0);
      const onL1SideOfL2 = (ptSideOfL2 > 0) === (l1SideOfL2 > 0);
      
      return onL2SideOfL1 && onL1SideOfL2;
    }

    function samplePts(ring, n = 100) {
      if (!ring || ring.length < 3) return [];
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      ring.forEach(([x, y]) => { minX = Math.min(minX, x); maxX = Math.max(maxX, x); minY = Math.min(minY, y); maxY = Math.max(maxY, y); });
      const sx = (maxX - minX) / n, sy = (maxY - minY) / n;
      const pts = [];
      for (let i = 0; i <= n; i++) for (let j = 0; j <= n; j++) {
        const p = [minX + i * sx, minY + j * sy];
        if (pointInPoly(p, ring)) pts.push(p);
      }
      return pts;
    }

    function centroid(pts) {
      if (!pts.length) return [0, 0];
      let sx = 0, sy = 0;
      pts.forEach(([x, y]) => { sx += x; sy += y; });
      return [sx / pts.length, sy / pts.length];
    }

    // Find the best label position within a zone
    // Uses pole of inaccessibility approach - find point furthest from zone edges
    function findBestZoneLabel(zone, ring, splitLines) {
      if (!zone || zone.length === 0) return null;
      if (zone.length === 1) return zone[0];
      
      // Find the point in the zone that is furthest from all boundaries
      // (both the area ring and any split lines)
      let bestPt = null;
      let maxMinDist = -Infinity;
      
      for (const pt of zone) {
        let minDist = Infinity;
        
        // Distance to area boundary
        for (let i = 0; i < ring.length - 1; i++) {
          minDist = Math.min(minDist, distToSeg(pt, ring[i], ring[i + 1]));
        }
        
        // Distance to split lines if provided
        if (splitLines) {
          for (const line of splitLines) {
            if (line && line.length >= 2) {
              for (let i = 0; i < line.length - 1; i++) {
                minDist = Math.min(minDist, distToSeg(pt, line[i], line[i + 1]));
              }
            }
          }
        }
        
        if (minDist > maxMinDist) {
          maxMinDist = minDist;
          bestPt = pt;
        }
      }
      
      return bestPt || zone[0];
    }

    function lineInt(a, b, c, d) {
      const [x1, y1, x2, y2, x3, y3, x4, y4] = [a[0], a[1], b[0], b[1], c[0], c[1], d[0], d[1]];
      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(den) < 1e-10) return null;
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
      const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
      return (t >= 0 && t <= 1 && u >= 0 && u <= 1) ? [x1 + t * (x2 - x1), y1 + t * (y2 - y1)] : null;
    }

    function extendToBnd(pt, dir, ring) {
      const far = [pt[0] + dir[0] * 1000, pt[1] + dir[1] * 1000];
      let best = null, minD = Infinity;
      for (let i = 0; i < ring.length - 1; i++) {
        const h = lineInt(pt, far, ring[i], ring[i + 1]);
        if (h) {
          const d = Math.hypot(h[0] - pt[0], h[1] - pt[1]);
          if (d > 0.0001 && d < minD) { minD = d; best = h; }
        }
      }
      return best;
    }

    function extendLine(coords, ring) {
      if (!coords || coords.length < 2) return coords;
      const fd = [coords[0][0] - coords[1][0], coords[0][1] - coords[1][1]];
      const fl = Math.hypot(fd[0], fd[1]);
      const fn = fl > 0 ? [fd[0] / fl, fd[1] / fl] : [0, 0];
      const sb = extendToBnd(coords[0], fn, ring);

      const li = coords.length - 1;
      const ld = [coords[li][0] - coords[li - 1][0], coords[li][1] - coords[li - 1][1]];
      const ll = Math.hypot(ld[0], ld[1]);
      const ln = ll > 0 ? [ld[0] / ll, ld[1] / ll] : [0, 0];
      const eb = extendToBnd(coords[li], ln, ring);

      return [...(sb ? [sb] : []), ...coords, ...(eb ? [eb] : [])];
    }

    function clipLine(coords, ring) {
      const solid = [], dashed = [];

      for (let i = 0; i < coords.length - 1; i++) {
        const p1 = coords[i], p2 = coords[i + 1];
        const i1 = pointInPoly(p1, ring), i2 = pointInPoly(p2, ring);

        if (i1 && i2) { solid.push([p1, p2]); continue; }

        if (!i1 && !i2) {
          const cr = [];
          for (let j = 0; j < ring.length - 1; j++) {
            const h = lineInt(p1, p2, ring[j], ring[j + 1]);
            if (h) cr.push({ pt: h, d: Math.hypot(h[0] - p1[0], h[1] - p1[1]) });
          }
          if (cr.length >= 2) {
            cr.sort((a, b) => a.d - b.d);
            dashed.push([p1, cr[0].pt]);
            solid.push([cr[0].pt, cr[1].pt]);
            dashed.push([cr[1].pt, p2]);
          } else {
            dashed.push([p1, p2]);
          }
          continue;
        }

        let cr = null;
        for (let j = 0; j < ring.length - 1; j++) {
          const h = lineInt(p1, p2, ring[j], ring[j + 1]);
          if (h) { cr = h; break; }
        }

        if (cr) {
          if (i1) { solid.push([p1, cr]); dashed.push([cr, p2]); }
          else { dashed.push([p1, cr]); solid.push([cr, p2]); }
        } else {
          (i1 || i2) ? solid.push([p1, p2]) : dashed.push([p1, p2]);
        }
      }

      return { solid, dashed };
    }

    function drawSplits() {
      const solidF = [], dashF = [], ptF = [], lblF = [];
      const seen = new Set();

      const addPt = (a, p) => {
        const k = `${a}|${p.name}`;
        if (seen.has(k)) return;
        seen.add(k);
        ptF.push({ type: 'Feature', properties: { name: p.name }, geometry: { type: 'Point', coordinates: p.coord } });
      };

      const buildCoords = s => tokenize(s).map(resolveToken).filter(Boolean);
      const getRing = c => areaGeoJSON.features.find(f => f.properties.area_code.toUpperCase() === c.toUpperCase())?.geometry.coordinates[0];

      Object.entries(areaSplits).forEach(([code, rules]) => {
        const ring = getRing(code);
        if (!ring) return;

        const ruleData = rules.map((r, i) => {
          const d = { rule: r, idx: i, lhs: null, rhs: null };

          if (r.type === 'between') {
            const lp = buildCoords(r.lhs), rp = buildCoords(r.rhs);
            lp.forEach(p => addPt(code, p)); rp.forEach(p => addPt(code, p));

            if (lp.length >= 2) {
              d.lhs = extendLine(lp.map(p => p.coord), ring);
              const { solid, dashed } = clipLine(d.lhs, ring);
              solid.forEach(s => solidF.push({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: s } }));
              dashed.forEach(s => dashF.push({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: s } }));
            }

            if (rp.length >= 2) {
              d.rhs = extendLine(rp.map(p => p.coord), ring);
              const { solid, dashed } = clipLine(d.rhs, ring);
              solid.forEach(s => solidF.push({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: s } }));
              dashed.forEach(s => dashF.push({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: s } }));
            }
          }

          if (r.type === 'of') {
            const pts = buildCoords(r.lhs);
            pts.forEach(p => addPt(code, p));

            if (pts.length >= 2) {
              d.lhs = extendLine(pts.map(p => p.coord), ring);
              const { solid, dashed } = clipLine(d.lhs, ring);
              solid.forEach(s => solidF.push({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: s } }));
              dashed.forEach(s => dashF.push({ type: 'Feature', properties: {}, geometry: { type: 'LineString', coordinates: s } }));
            }
          }

          return d;
        });

        const samples = samplePts(ring, 200);

        rules.forEach((r, i) => {
          if (!r.qnh) return;
          const d = ruleData[i];
          let zone = [];

          if (r.type === 'of' && r.dir && d.lhs?.length >= 2) {
            zone = samples.filter(p => onCompassSide(p, d.lhs, r.dir));
          } else if (r.type === 'between' && d.lhs && d.rhs) {
            zone = samples.filter(p => between(p, d.lhs, d.rhs));
          } else if (r.type === 'rest') {
            zone = samples.filter(p => {
              // Check if point is on any split line (hard border)
              for (let j = 0; j < rules.length; j++) {
                if (!rules[j].qnh) continue;
                const od = ruleData[j];
                if (od.lhs) {
                  for (let k = 0; k < od.lhs.length - 1; k++) {
                    if (distToSeg(p, od.lhs[k], od.lhs[k + 1]) < 0.003) return false;
                  }
                }
                if (od.rhs) {
                  for (let k = 0; k < od.rhs.length - 1; k++) {
                    if (distToSeg(p, od.rhs[k], od.rhs[k + 1]) < 0.003) return false;
                  }
                }
              }
              
              // Check if point is in any other defined zone
              for (let j = 0; j < rules.length; j++) {
                if (j === i || !rules[j].qnh) continue;
                const o = rules[j], od = ruleData[j];
                if (o.type === 'of' && o.dir && od.lhs && onCompassSide(p, od.lhs, o.dir)) return false;
                if (o.type === 'between' && od.lhs && od.rhs && between(p, od.lhs, od.rhs)) return false;
              }
              return true;
            });
          }

          if (zone.length) {
            // Collect all split lines for this area
            const allSplitLines = ruleData
              .filter(rd => rd.lhs || rd.rhs)
              .flatMap(rd => [rd.lhs, rd.rhs].filter(Boolean));
            
            // Use improved label positioning that ensures label is within the zone
            const labelPos = findBestZoneLabel(zone, ring, allSplitLines);

            lblF.push({
              type: 'Feature',
              properties: {
                qnh: r.qnh,
                area_num: code.slice(5) // AREA-80 -> 80
              },
              geometry: { type: 'Point', coordinates: labelPos }
            });
          }
        });
      });

      const upd = (id, fc, cfg) => {
        if (map.getSource(id)) map.getSource(id).setData(fc);
        else { map.addSource(id, { type: 'geojson', data: fc }); map.addLayer(cfg); }
      };

      // Split lines, green
      upd('split-solid', { type: 'FeatureCollection', features: solidF }, {
        id: 'split-solid', type: 'line', source: 'split-solid',
        paint: { 'line-color': '#1a8f2a', 'line-width': 1.5 }
      });

      upd('split-dash', { type: 'FeatureCollection', features: dashF }, {
        id: 'split-dash', type: 'line', source: 'split-dash',
        paint: { 'line-color': '#1a8f2a', 'line-width': 1.5, 'line-dasharray': [3, 3] }
      });

      // Split QNH labels, green
      upd('split-lbl', { type: 'FeatureCollection', features: lblF }, {
        id: 'split-lbl',
        type: 'symbol',
        source: 'split-lbl',
        layout: {
          'text-field': ['to-string', ['get', 'qnh']],
          'text-font': ['Noto Sans Regular'],
          'text-size': 16,
          'text-allow-overlap': true
        },
        paint: {
          'text-color': '#1a8f2a',
          'text-halo-color': '#ffffff',
          'text-halo-width': 2
        }
      });

      // Area label under split QNH, red (only for splits)
      if (!map.getLayer('split-lbl-area')) {
        map.addLayer({
          id: 'split-lbl-area',
          type: 'symbol',
          source: 'split-lbl',
          layout: {
            'text-field': ['concat', 'AREA ', ['get', 'area_num']],
            'text-font': ['Noto Sans Regular'],
            'text-size': 11,
            'text-offset': [0, 1.2],
            'text-anchor': 'top',
            'text-allow-overlap': true
          },
          paint: {
            'text-color': '#ff0000',
            'text-halo-color': '#ffffff',
            'text-halo-width': 2
          }
        });
      }

      // Split reference points
      if (!map.getSource('split-pts')) {
        map.addSource('split-pts', { type: 'geojson', data: { type: 'FeatureCollection', features: ptF } });

        map.addLayer({
          id: 'split-pts',
          type: 'symbol',
          source: 'split-pts',
          layout: { 'text-field': '√ó', 'text-size': 14, 'text-allow-overlap': true },
          paint: { 'text-color': '#000000', 'text-halo-color': '#ffffff', 'text-halo-width': 1.5 }
        });

        map.addLayer({
          id: 'split-pt-lbl',
          type: 'symbol',
          source: 'split-pts',
          layout: { 'text-field': ['get', 'name'], 'text-size': 9, 'text-offset': [0, 1.2], 'text-anchor': 'top' },
          paint: { 'text-color': '#1f6feb', 'text-halo-color': '#ffffff', 'text-halo-width': 1.5 }
        });
      } else {
        map.getSource('split-pts').setData({ type: 'FeatureCollection', features: ptF });
      }

      // Debug dots for AREA-20 zones - different color per split
    }

    // ====== ZONE VALIDATION & DEBUG SYSTEM ======

    let debugMode = false;
    let validationResults = null;

    // Validate zones for overlaps and gaps
    function validateZones() {
      console.log('Running zone validation...');
      const results = { areas: [], totalOverlap: 0, totalGap: 0, splitAreas: 0 };

      Object.entries(areaSplits).forEach(([code, rules]) => {
        const ring = areaGeoJSON.features.find(f => f.properties.area_code === code)?.geometry.coordinates[0];
        if (!ring) return;

        results.splitAreas++;

        // Build rule data (same as drawSplits)
        const buildCoords = s => tokenize(s).map(resolveToken).filter(Boolean);
        const ruleData = rules.map(r => {
          const d = { rule: r, lhs: null, rhs: null };

          if (r.type === 'between') {
            const lp = buildCoords(r.lhs), rp = buildCoords(r.rhs);
            if (lp.length >= 2) d.lhs = extendLine(lp.map(p => p.coord), ring);
            if (rp.length >= 2) d.rhs = extendLine(rp.map(p => p.coord), ring);
          }

          if (r.type === 'of') {
            const pts = buildCoords(r.lhs);
            if (pts.length >= 2) d.lhs = extendLine(pts.map(p => p.coord), ring);
          }

          return d;
        });

        // Sample the area at lower resolution for validation (80x80 grid)
        const samples = samplePts(ring, 80);

        // Check each point to see how many zones it belongs to
        const zoneCounts = new Array(samples.length).fill(0);

        samples.forEach((p, idx) => {
          rules.forEach((r, i) => {
            if (!r.qnh) return;
            const d = ruleData[i];
            let inZone = false;

            if (r.type === 'of' && r.dir && d.lhs?.length >= 2) {
              inZone = onCompassSide(p, d.lhs, r.dir);
            } else if (r.type === 'between' && d.lhs && d.rhs) {
              inZone = between(p, d.lhs, d.rhs);
            } else if (r.type === 'rest') {
              // Check if point is on any split line (hard border)
              let onBorder = false;
              for (let j = 0; j < rules.length; j++) {
                if (!rules[j].qnh) continue;
                const od = ruleData[j];
                if (od.lhs) {
                  for (let k = 0; k < od.lhs.length - 1; k++) {
                    if (distToSeg(p, od.lhs[k], od.lhs[k + 1]) < 0.003) {
                      onBorder = true;
                      break;
                    }
                  }
                }
                if (onBorder) break;
                if (od.rhs) {
                  for (let k = 0; k < od.rhs.length - 1; k++) {
                    if (distToSeg(p, od.rhs[k], od.rhs[k + 1]) < 0.003) {
                      onBorder = true;
                      break;
                    }
                  }
                }
                if (onBorder) break;
              }

              if (onBorder) return;

              // Check if point is in any other defined zone
              let inOtherZone = false;
              for (let j = 0; j < rules.length; j++) {
                if (j === i || !rules[j].qnh) continue;
                const o = rules[j], od = ruleData[j];
                if (o.type === 'of' && o.dir && od.lhs && onCompassSide(p, od.lhs, o.dir)) {
                  inOtherZone = true;
                  break;
                }
                if (o.type === 'between' && od.lhs && od.rhs && between(p, od.lhs, od.rhs)) {
                  inOtherZone = true;
                  break;
                }
              }

              inZone = !inOtherZone;
            }

            if (inZone) zoneCounts[idx]++;
          });
        });

        // Calculate overlap and gap percentages
        const overlaps = zoneCounts.filter(c => c > 1).length;
        const gaps = zoneCounts.filter(c => c === 0).length;
        const overlapPct = (overlaps / samples.length) * 100;
        const gapPct = (gaps / samples.length) * 100;

        results.totalOverlap += overlapPct;
        results.totalGap += gapPct;

        results.areas.push({
          code,
          samples: samples.length,
          overlaps,
          gaps,
          overlapPct: overlapPct.toFixed(2),
          gapPct: gapPct.toFixed(2),
          hasIssues: overlapPct > 1 || gapPct > 1
        });

        // Log to console with color coding
        if (overlapPct > 1 || gapPct > 1) {
          console.warn(`‚ö†Ô∏è ${code}: ${overlapPct.toFixed(1)}% overlaps, ${gapPct.toFixed(1)}% gaps`);
        } else {
          console.log(`‚úì ${code}: ${overlapPct.toFixed(1)}% overlaps, ${gapPct.toFixed(1)}% gaps`);
        }
      });

      // Calculate averages
      if (results.splitAreas > 0) {
        results.avgOverlap = (results.totalOverlap / results.splitAreas).toFixed(2);
        results.avgGap = (results.totalGap / results.splitAreas).toFixed(2);
      }

      validationResults = results;
      return results;
    }

    // Render debug dots showing overlaps (red) and gaps (blue)
    function renderDebugDots() {
      if (!debugMode || !validationResults) return;

      const overlapFeatures = [];
      const gapFeatures = [];

      validationResults.areas.forEach(areaResult => {
        const ring = areaGeoJSON.features.find(f => f.properties.area_code === areaResult.code)?.geometry.coordinates[0];
        if (!ring) return;

        const rules = areaSplits[areaResult.code];
        if (!rules) return;

        // Build rule data
        const buildCoords = s => tokenize(s).map(resolveToken).filter(Boolean);
        const ruleData = rules.map(r => {
          const d = { rule: r, lhs: null, rhs: null };

          if (r.type === 'between') {
            const lp = buildCoords(r.lhs), rp = buildCoords(r.rhs);
            if (lp.length >= 2) d.lhs = extendLine(lp.map(p => p.coord), ring);
            if (rp.length >= 2) d.rhs = extendLine(rp.map(p => p.coord), ring);
          }

          if (r.type === 'of') {
            const pts = buildCoords(r.lhs);
            if (pts.length >= 2) d.lhs = extendLine(pts.map(p => p.coord), ring);
          }

          return d;
        });

        const samples = samplePts(ring, 80);

        samples.forEach(p => {
          let zoneCount = 0;

          rules.forEach((r, i) => {
            if (!r.qnh) return;
            const d = ruleData[i];
            let inZone = false;

            if (r.type === 'of' && r.dir && d.lhs?.length >= 2) {
              inZone = onCompassSide(p, d.lhs, r.dir);
            } else if (r.type === 'between' && d.lhs && d.rhs) {
              inZone = between(p, d.lhs, d.rhs);
            } else if (r.type === 'rest') {
              // Check if on border
              let onBorder = false;
              for (let j = 0; j < rules.length; j++) {
                if (!rules[j].qnh) continue;
                const od = ruleData[j];
                if (od.lhs) {
                  for (let k = 0; k < od.lhs.length - 1; k++) {
                    if (distToSeg(p, od.lhs[k], od.lhs[k + 1]) < 0.003) {
                      onBorder = true;
                      break;
                    }
                  }
                }
                if (onBorder) break;
                if (od.rhs) {
                  for (let k = 0; k < od.rhs.length - 1; k++) {
                    if (distToSeg(p, od.rhs[k], od.rhs[k + 1]) < 0.003) {
                      onBorder = true;
                      break;
                    }
                  }
                }
                if (onBorder) break;
              }

              if (onBorder) return;

              let inOtherZone = false;
              for (let j = 0; j < rules.length; j++) {
                if (j === i || !rules[j].qnh) continue;
                const o = rules[j], od = ruleData[j];
                if (o.type === 'of' && o.dir && od.lhs && onCompassSide(p, od.lhs, o.dir)) {
                  inOtherZone = true;
                  break;
                }
                if (o.type === 'between' && od.lhs && od.rhs && between(p, od.lhs, od.rhs)) {
                  inOtherZone = true;
                  break;
                }
              }

              inZone = !inOtherZone;
            }

            if (inZone) zoneCount++;
          });

          // Add debug dot for overlaps (red) and gaps (blue)
          if (zoneCount > 1) {
            overlapFeatures.push({
              type: 'Feature',
              properties: { count: zoneCount },
              geometry: { type: 'Point', coordinates: p }
            });
          } else if (zoneCount === 0) {
            gapFeatures.push({
              type: 'Feature',
              properties: {},
              geometry: { type: 'Point', coordinates: p }
            });
          }
        });
      });

      // Add overlap dots (red)
      if (map.getSource('debug-overlaps')) {
        map.getSource('debug-overlaps').setData({ type: 'FeatureCollection', features: overlapFeatures });
      } else {
        map.addSource('debug-overlaps', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: overlapFeatures }
        });
        map.addLayer({
          id: 'debug-overlaps',
          type: 'circle',
          source: 'debug-overlaps',
          paint: {
            'circle-radius': 3,
            'circle-color': '#ff0000',
            'circle-opacity': 0.6
          }
        });
      }

      // Add gap dots (blue)
      if (map.getSource('debug-gaps')) {
        map.getSource('debug-gaps').setData({ type: 'FeatureCollection', features: gapFeatures });
      } else {
        map.addSource('debug-gaps', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: gapFeatures }
        });
        map.addLayer({
          id: 'debug-gaps',
          type: 'circle',
          source: 'debug-gaps',
          paint: {
            'circle-radius': 3,
            'circle-color': '#0000ff',
            'circle-opacity': 0.6
          }
        });
      }
    }

    // Track which areas have polygons visible
    const visibleAreaPolygons = new Set();

    // Update debug panel content
    function updateDebugPanel() {
      const content = $('debugContent');

      if (!validationResults) {
        content.innerHTML = '<p style="color: var(--text-muted);">Running validation...</p>';
        return;
      }

      const r = validationResults;

      let html = `
        <div class="stat">
          <span class="stat-label">Split areas:</span>
          <span class="stat-value">${r.splitAreas}</span>
        </div>
        <div class="stat">
          <span class="stat-label">Avg overlap:</span>
          <span class="stat-value ${parseFloat(r.avgOverlap) > 1 ? 'warn' : 'good'}">${r.avgOverlap}%</span>
        </div>
        <div class="stat">
          <span class="stat-label">Avg gap:</span>
          <span class="stat-value ${parseFloat(r.avgGap) > 1 ? 'warn' : 'good'}">${r.avgGap}%</span>
        </div>
        <hr style="margin: 8px 0; border: none; border-top: 1px solid var(--border);">
      `;

      r.areas.forEach(a => {
        const issueClass = a.hasIssues ? 'has-issues' : '';
        const isVisible = visibleAreaPolygons.has(a.code);
        html += `
          <div class="area-validation ${issueClass}">
            <strong>${a.code}</strong><br>
            Samples: ${a.samples}<br>
            Overlaps: ${a.overlaps} (${a.overlapPct}%)<br>
            Gaps: ${a.gaps} (${a.gapPct}%)
            <div class="area-controls">
              <button onclick="toggleAreaPolygons('${a.code}')" class="${isVisible ? 'active' : ''}">
                ${isVisible ? '‚úì Hide' : 'Show'} Zones
              </button>
            </div>
          </div>
        `;
      });

      html += `
        <p style="margin-top: 8px; font-size: 0.7rem; color: var(--text-muted);">
          Red dots = overlaps<br>
          Blue dots = gaps<br>
          Colored dots = zone samples (stay inside borders)
        </p>
      `;

      content.innerHTML = html;
    }

    // Toggle debug mode
    function toggleDebug() {
      debugMode = !debugMode;
      const btn = $('debugBtn');
      const panel = $('debugPanel');

      if (debugMode) {
        btn.classList.add('active');
        panel.classList.add('visible');

        // Run validation
        updateDebugPanel();
        setTimeout(() => {
          try {
            validateZones();
            updateDebugPanel();
            renderDebugDots();
          } catch (err) {
            console.error('Validation error:', err);
            $('debugContent').innerHTML = `<p style="color: var(--error);">Error: ${err.message}</p>`;
          }
        }, 100);
      } else {
        btn.classList.remove('active');
        panel.classList.remove('visible');

        // Remove debug layers
        if (map.getLayer('debug-overlaps')) map.removeLayer('debug-overlaps');
        if (map.getSource('debug-overlaps')) map.removeSource('debug-overlaps');
        if (map.getLayer('debug-gaps')) map.removeLayer('debug-gaps');
        if (map.getSource('debug-gaps')) map.removeSource('debug-gaps');
      }
    }

    // Set up debug button
    document.addEventListener('DOMContentLoaded', () => {
      const btn = $('debugBtn');
      if (btn) {
        btn.addEventListener('click', toggleDebug);
      }
    });

    // ====== PER-AREA COLORED DOT VISUALIZATION ======

    // Toggle colored dots for a specific area
    window.toggleAreaPolygons = function(areaCode) {
      if (visibleAreaPolygons.has(areaCode)) {
        visibleAreaPolygons.delete(areaCode);
      } else {
        visibleAreaPolygons.add(areaCode);
      }

      renderAllAreaDots();
      updateDebugPanel();
    };

    // Render colored dots for all visible areas
    function renderAllAreaDots() {
      const dotFeatures = [];

      visibleAreaPolygons.forEach(code => {
        const rules = areaSplits[code];
        if (!rules) return;

        const ring = areaGeoJSON.features.find(f => f.properties.area_code === code)?.geometry.coordinates[0];
        if (!ring) return;

        // Build rule data
        const buildCoords = s => tokenize(s).map(resolveToken).filter(Boolean);
        const ruleData = rules.map(r => {
          const d = { rule: r, lhs: null, rhs: null };

          if (r.type === 'between') {
            const lp = buildCoords(r.lhs), rp = buildCoords(r.rhs);
            if (lp.length >= 2) d.lhs = extendLine(lp.map(p => p.coord), ring);
            if (rp.length >= 2) d.rhs = extendLine(rp.map(p => p.coord), ring);
          }

          if (r.type === 'of') {
            const pts = buildCoords(r.lhs);
            if (pts.length >= 2) d.lhs = extendLine(pts.map(p => p.coord), ring);
          }

          return d;
        });

        // Sample at higher resolution for better dot visualization
        const samples = samplePts(ring, 150);

        rules.forEach((r, i) => {
          if (!r.qnh) return;
          const d = ruleData[i];
          let zone = [];

          if (r.type === 'of' && r.dir && d.lhs?.length >= 2) {
            zone = samples.filter(p => {
              // CRITICAL: Point MUST be inside the area polygon first
              if (!pointInPoly(p, ring)) return false;

              // HARD BORDER: Exclude points near split lines (green lines) - 5x stronger
              for (let k = 0; k < d.lhs.length - 1; k++) {
                if (distToSeg(p, d.lhs[k], d.lhs[k + 1]) < 0.01) return false;
              }
              // HARD BORDER: Exclude points near area boundary (red lines) - 5x stronger
              for (let k = 0; k < ring.length - 1; k++) {
                if (distToSeg(p, ring[k], ring[k + 1]) < 0.01) return false;
              }
              return onCompassSide(p, d.lhs, r.dir);
            });
          } else if (r.type === 'between' && d.lhs && d.rhs) {
            zone = samples.filter(p => {
              // CRITICAL: Point MUST be inside the area polygon first
              if (!pointInPoly(p, ring)) return false;

              // HARD BORDER: Exclude points near both split lines - 5x stronger
              for (let k = 0; k < d.lhs.length - 1; k++) {
                if (distToSeg(p, d.lhs[k], d.lhs[k + 1]) < 0.01) return false;
              }
              for (let k = 0; k < d.rhs.length - 1; k++) {
                if (distToSeg(p, d.rhs[k], d.rhs[k + 1]) < 0.01) return false;
              }
              // HARD BORDER: Exclude points near area boundary - 5x stronger
              for (let k = 0; k < ring.length - 1; k++) {
                if (distToSeg(p, ring[k], ring[k + 1]) < 0.01) return false;
              }
              return between(p, d.lhs, d.rhs);
            });
          } else if (r.type === 'rest') {
            zone = samples.filter(p => {
              // CRITICAL: Point MUST be inside the area polygon first
              if (!pointInPoly(p, ring)) return false;

              // HARD BORDER: Exclude points near ANY split line - 5x stronger
              for (let j = 0; j < rules.length; j++) {
                if (!rules[j].qnh) continue;
                const od = ruleData[j];
                if (od.lhs) {
                  for (let k = 0; k < od.lhs.length - 1; k++) {
                    if (distToSeg(p, od.lhs[k], od.lhs[k + 1]) < 0.01) return false;
                  }
                }
                if (od.rhs) {
                  for (let k = 0; k < od.rhs.length - 1; k++) {
                    if (distToSeg(p, od.rhs[k], od.rhs[k + 1]) < 0.01) return false;
                  }
                }
              }

              // HARD BORDER: Exclude points near area boundary - 5x stronger
              for (let k = 0; k < ring.length - 1; k++) {
                if (distToSeg(p, ring[k], ring[k + 1]) < 0.01) return false;
              }

              // Check if point is in any other defined zone
              for (let j = 0; j < rules.length; j++) {
                if (j === i || !rules[j].qnh) continue;
                const o = rules[j], od = ruleData[j];
                if (o.type === 'of' && o.dir && od.lhs && onCompassSide(p, od.lhs, o.dir)) return false;
                if (o.type === 'between' && od.lhs && od.rhs && between(p, od.lhs, od.rhs)) return false;
              }
              return true;
            });
          }

          // Add colored dots for this zone
          zone.forEach(pt => {
            dotFeatures.push({
              type: 'Feature',
              properties: {
                area: code,
                qnh: r.qnh,
                zoneIndex: i
              },
              geometry: {
                type: 'Point',
                coordinates: pt
              }
            });
          });
        });
      });

      console.log(`Rendering ${dotFeatures.length} colored dots for ${visibleAreaPolygons.size} area(s)`);

      // Update or create dot layers
      if (map.getSource('zone-dots')) {
        map.getSource('zone-dots').setData({ type: 'FeatureCollection', features: dotFeatures });
      } else {
        map.addSource('zone-dots', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: dotFeatures }
        });

        map.addLayer({
          id: 'zone-dots',
          type: 'circle',
          source: 'zone-dots',
          paint: {
            'circle-radius': 2,
            'circle-color': [
              'case',
              ['==', ['%', ['get', 'zoneIndex'], 6], 0], '#ff6464',
              ['==', ['%', ['get', 'zoneIndex'], 6], 1], '#64ff64',
              ['==', ['%', ['get', 'zoneIndex'], 6], 2], '#6464ff',
              ['==', ['%', ['get', 'zoneIndex'], 6], 3], '#ffff64',
              ['==', ['%', ['get', 'zoneIndex'], 6], 4], '#ff64ff',
              ['==', ['%', ['get', 'zoneIndex'], 6], 5], '#64ffff',
              '#c8c8c8'
            ],
            'circle-opacity': 0.7
          }
        });
      }
    }

    // Toggle dots for a specific area
    window.toggleAreaDots = function(areaCode) {
      console.log(`Toggling dots for ${areaCode}`);
      // TODO: Implement per-area dot visualization if needed
    };
  </script>
</body>

</html>