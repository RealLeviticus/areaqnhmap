<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Area QNH Map</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    :root {
      --panel: #f7f7f7;
      --stroke: #d6d6d6;
      --label-red: #c40000;
      --warn-bg: #fff4d7;
      --warn-border: #f0c96a;
      --warn-text: #7a5a05;
      --success-bg: #d4edda;
      --success-border: #c3e6cb;
      --success-text: #155724;
    }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: #ffffff;
      color: #111;
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
    }
    header {
      padding: 14px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--panel);
      border-bottom: 1px solid var(--stroke);
      gap: 8px;
      flex-wrap: wrap;
    }
    .title h1 { margin: 0; font-size: 1.1rem; }
    .title .sub { margin: 0; font-size: 0.9rem; color: #555; }
    #validity {
      margin-left: auto;
      font-size: 0.9rem;
      color: #444;
      white-space: nowrap;
    }
    main {
      padding: 16px;
      display: flex;
      flex-direction: column;
    }
    #warning, #success {
      margin-bottom: 12px;
      padding: 10px 12px;
      border: 1px solid var(--warn-border);
      border-radius: 10px;
      background: var(--warn-bg);
      color: var(--warn-text);
      font-size: 0.95rem;
      display: none;
    }
    #success {
      background: var(--success-bg);
      border-color: var(--success-border);
      color: var(--success-text);
    }
    #map {
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      min-height: 0;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.18);
      background: #edf1f5;
    }
    .legend {
      position: absolute;
      bottom: 30px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      font-size: 0.85rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1;
    }
    .legend h4 {
      margin: 0 0 8px 0;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }
    .legend-line {
      width: 24px;
      height: 3px;
      background: #1f9e45;
    }
    .legend-point {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Area QNH Map</h1>
      <p class="sub">Replica of the BOM Area QNH Map removed from the new BOM website.</p>
    </div>
    <div id="validity">Fetching QNH...</div>
  </header>

  <main>
    <div id="warning" role="status" aria-live="polite"></div>
    <div id="success" role="status" aria-live="polite"></div>
    <div id="map" aria-label="Area QNH map">
      <div class="legend">
        <h4>Legend</h4>
        <div class="legend-item">
          <div class="legend-line"></div>
          <span>Split boundary</span>
        </div>
        <div class="legend-item">
          <div class="legend-point">×</div>
          <span>Reference point</span>
        </div>
      </div>
    </div>
  </main>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
    const warningBox = document.getElementById('warning');
    const successBox = document.getElementById('success');
    
    const showWarning = (message) => {
      if (!message) return;
      warningBox.textContent = message;
      warningBox.style.display = 'block';
      setTimeout(() => warningBox.style.display = 'none', 8000);
    };

    const showSuccess = (message) => {
      if (!message) return;
      successBox.textContent = message;
      successBox.style.display = 'block';
      setTimeout(() => successBox.style.display = 'none', 5000);
    };

    const QNH_WORKER_URL = 'https://areaqnh.therealleviticus.workers.dev/';
    const NAV_INDEX_URL = 'https://airspace.therealleviticus.workers.dev/';

    const AREA_DATA = {"type":"FeatureCollection","features":[{"type":"Feature","properties":{"area_code":"AREA-20","name":"QNH_AREA_20","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[148.383333,-32.75],[150.0,-29.0],[154.703056,-28.043611],[155.0,-28.833333],[152.666667,-34.333333],[151.177222,-33.946111],[150.988333,-33.924444],[149.651944,-33.409444],[148.383333,-32.75]]]}},{"type":"Feature","properties":{"area_code":"AREA-21","name":"QNH_AREA_21","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[146.924722,-36.195278],[148.383333,-32.75],[149.651944,-33.409444],[150.988333,-33.924444],[151.177222,-33.946111],[152.666667,-34.333333],[150.870556,-37.881111],[149.976111,-37.503889],[146.924722,-36.195278]]]}},{"type":"Feature","properties":{"area_code":"AREA-22","name":"QNH_AREA_22","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[141.0,-29.0],[150.0,-29.0],[148.383333,-32.75],[146.924722,-36.195278],[141.0,-33.65],[141.0,-29.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-24","name":"QNH_AREA_24","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[152.666667,-34.333333],[155.0,-28.833333],[163.0,-28.5],[163.0,-31.333333],[152.666667,-34.333333]]]}},{"type":"Feature","properties":{"area_code":"AREA-30","name":"QNH_AREA_30","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[141.0,-33.65],[146.924722,-36.195278],[149.976111,-37.503889],[150.870556,-37.881111],[150.2,-39.57],[142.8575,-39.57],[141.0,-39.57],[141.0,-33.65]]]}},{"type":"Feature","properties":{"area_code":"AREA-40","name":"QNH_AREA_40","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[147.820833,-23.156111],[152.864444,-23.155833],[154.703056,-28.043611],[150.0,-29.0],[148.183333,-23.566667],[147.820833,-23.156111]]]}},{"type":"Feature","properties":{"area_code":"AREA-41","name":"QNH_AREA_41","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[138.0,-26.0],[138.0,-23.156111],[147.820833,-23.156111],[148.183333,-23.566667],[150.0,-29.0],[141.0,-29.0],[141.0,-26.0],[138.0,-26.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-43","name":"QNH_AREA_43","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[138.0,-23.156111],[138.0,-19.0],[143.533333,-18.3],[147.820833,-23.156111],[138.0,-23.156111]]]}},{"type":"Feature","properties":{"area_code":"AREA-44","name":"QNH_AREA_44","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[143.533333,-18.3],[148.0,-18.283333],[152.864444,-23.155833],[147.820833,-23.156111],[143.533333,-18.3]]]}},{"type":"Feature","properties":{"area_code":"AREA-45","name":"QNH_AREA_45","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[141.0,-9.833333],[141.033333,-9.616667],[142.083333,-9.261667],[142.805,-9.323889],[143.875,-9.133333],[144.233333,-9.4],[144.089167,-9.942778],[144.026667,-11.5],[144.072222,-11.725],[144.0,-12.0],[147.607778,-16.995833],[148.0,-18.283333],[143.533333,-18.3],[138.0,-19.0],[138.0,-14.0],[141.0,-9.833333]]]}},{"type":"Feature","properties":{"area_code":"AREA-50","name":"QNH_AREA_50","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[134.5,-35.5],[135.372222,-34.686667],[137.716667,-32.5],[141.0,-33.65],[141.0,-39.57],[134.5,-35.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-51","name":"QNH_AREA_51","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[135.0,-30.0],[141.0,-29.0],[141.0,-33.65],[137.716667,-32.5],[135.0,-30.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-52","name":"QNH_AREA_52","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-26.0],[138.0,-26.0],[141.0,-26.0],[141.0,-29.0],[135.0,-30.0],[129.0,-30.0],[129.0,-26.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-53","name":"QNH_AREA_53","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-30.0],[135.0,-30.0],[137.716667,-32.5],[135.372222,-34.686667],[134.5,-35.5],[131.0,-32.5],[129.0,-33.0],[129.0,-30.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-60","name":"QNH_AREA_60","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.5,-27.5],[118.0,-27.5],[119.0,-32.25],[113.5,-33.5],[112.5,-27.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-61","name":"QNH_AREA_61","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[119.0,-32.25],[118.0,-27.5],[123.5,-27.5],[123.618333,-30.84],[119.0,-32.25]]]}},{"type":"Feature","properties":{"area_code":"AREA-62","name":"QNH_AREA_62","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[123.618333,-30.84],[129.0,-30.0],[129.0,-33.0],[123.5,-35.0],[123.618333,-30.84]]]}},{"type":"Feature","properties":{"area_code":"AREA-63","name":"QNH_AREA_63","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[113.5,-33.5],[119.0,-32.25],[123.618333,-30.84],[123.5,-35.0],[116.0,-36.25],[113.5,-33.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-64","name":"QNH_AREA_64","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[123.5,-23.88],[129.0,-23.88],[129.0,-30.0],[123.618333,-30.84],[123.5,-27.5],[123.5,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-65","name":"QNH_AREA_65","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.096944,-23.88],[115.984722,-23.88],[118.0,-27.5],[112.5,-27.5],[112.096944,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-66","name":"QNH_AREA_66","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[115.984722,-23.88],[123.5,-23.88],[123.5,-27.5],[118.0,-27.5],[115.984722,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-68","name":"QNH_AREA_68","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.0,-23.0],[113.0,-21.0],[117.0,-18.0],[120.0,-18.0],[123.5,-20.5],[123.5,-23.88],[115.984722,-23.88],[112.096944,-23.88],[112.0,-23.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-69","name":"QNH_AREA_69","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[117.0,-18.0],[124.0,-14.0],[126.148056,-13.751667],[127.5,-14.0],[128.416667,-14.833333],[129.0,-14.879444],[129.0,-20.0],[123.5,-20.5],[120.0,-18.0],[117.0,-18.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-70","name":"QNH_AREA_70","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[142.8575,-39.57],[150.2,-39.57],[149.0,-43.0],[147.5,-44.5],[145.0,-44.0],[142.8575,-39.57]]]}},{"type":"Feature","properties":{"area_code":"AREA-80","name":"QNH_AREA_80","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-9.409722],[141.0,-9.833333],[138.0,-14.0],[138.0,-19.0],[129.0,-15.884444],[129.0,-14.879444],[129.0,-9.409722]]]}},{"type":"Feature","properties":{"area_code":"AREA-83","name":"QNH_AREA_83","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[123.5,-20.5],[129.0,-20.0],[129.0,-23.88],[123.5,-23.88],[123.5,-20.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-84","name":"QNH_AREA_84","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-20.0],[129.0,-15.884444],[138.0,-19.0],[138.0,-23.156111],[129.0,-22.25],[129.0,-20.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-85","name":"QNH_AREA_85","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-23.88],[129.0,-22.25],[138.0,-23.156111],[138.0,-26.0],[129.0,-26.0],[129.0,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-86","name":"QNH_AREA_86","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[124.774444,-10.9125],[126.833333,-9.333333],[129.0,-9.409722],[129.0,-14.879444],[128.416667,-14.833333],[127.5,-14.0],[126.148056,-13.751667],[124.0,-14.0],[124.774444,-10.9125]]]}},{"type":"Feature","properties":{"area_code":"AREA-87","name":"QNH_AREA_87","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.0,-18.0],[118.0,-15.0],[124.0,-14.0],[117.0,-18.0],[112.0,-18.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-88","name":"QNH_AREA_88","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[110.0,-19.0],[112.0,-18.0],[117.0,-18.0],[113.0,-21.0],[110.0,-19.0]]]}}]};

    let areaGeoJSON = null;
    let areaQnhMap = {};
    let areaSplits = {};
    let navPointMap = {};
    let navIndexPromise = null;

    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
        sources: {
          osm: {
            type: 'raster',
            tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [{ id: 'osm-base', type: 'raster', source: 'osm' }]
      },
      center: [134.5, -25.5],
      zoom: 3.6
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-left');

    map.on('error', (e) => {
      const { resourceType, sourceId } = e || {};
      if (resourceType === 'glyphs') {
        showWarning('Map labels may be missing due to font loading issues.');
      }
      if (resourceType === 'tile' && sourceId === 'osm') {
        showWarning('Base map tiles failed to load. Check network connectivity.');
      }
    });

    map.on('load', () => {
      loadAreas();
      ensureNavIndex();
      startQNHLoop();
    });

    async function loadAreas() {
      const geojson = JSON.parse(JSON.stringify(AREA_DATA));
      geojson.features.forEach((f, i) => f.id = i + 1);
      areaGeoJSON = geojson;

      map.addSource('areas', { type: 'geojson', data: geojson });

      map.addLayer({
        id: 'areas-fill',
        type: 'fill',
        source: 'areas',
        paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.30 }
      });

      map.addLayer({
        id: 'areas-line',
        type: 'line',
        source: 'areas',
        paint: { 'line-color': '#d40000', 'line-width': 2 }
      });

      // Create label points from area polygons
      createAreaLabels();

      applyAreaQnhToPolygons();
      fitToAreas(geojson);
    }

    // Find the optimal label position inside a polygon (pole of inaccessibility)
    function findOptimalLabelPosition(ring, gridSize = 40) {
      if (!ring || ring.length < 3) return [0, 0];

      // Find bounding box
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      ring.forEach(([x, y]) => {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      });

      const width = maxX - minX;
      const height = maxY - minY;
      const stepX = width / gridSize;
      const stepY = height / gridSize;

      // Generate sample points inside the polygon with a margin from edges
      const samplePoints = [];
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          const x = minX + i * stepX;
          const y = minY + j * stepY;
          const point = [x, y];

          // Check if point is inside polygon
          if (pointInPolygonHelper(point, ring)) {
            samplePoints.push(point);
          }
        }
      }

      if (samplePoints.length === 0) {
        console.error('No sample points found inside polygon! Trying finer grid...');
        // Try with a much finer grid
        const fineStepX = width / 100;
        const fineStepY = height / 100;

        for (let i = 0; i <= 100; i++) {
          for (let j = 0; j <= 100; j++) {
            const x = minX + i * fineStepX;
            const y = minY + j * fineStepY;
            const point = [x, y];
            if (pointInPolygonHelper(point, ring)) {
              console.log('Found point with finer grid');
              return point; // Return first point found
            }
          }
        }

        console.error('Could not find ANY point inside polygon even with fine grid!');
        return [minX + width/2, minY + height/2]; // Last resort: bounding box center
      }

      // Find the point that's furthest from all edges (pole of inaccessibility)
      let bestPoint = samplePoints[0];
      let maxMinDist = 0;

      for (const pt of samplePoints) {
        let minDistToBoundary = Infinity;

        // Check distance to each edge of the polygon
        for (let i = 0; i < ring.length - 1; i++) {
          const dist = distanceToSegment(pt, ring[i], ring[i + 1]);
          minDistToBoundary = Math.min(minDistToBoundary, dist);
        }

        // Keep track of the point with maximum distance to nearest boundary
        if (minDistToBoundary > maxMinDist) {
          maxMinDist = minDistToBoundary;
          bestPoint = pt;
        }
      }

      // Verify the best point is actually inside the polygon
      if (!pointInPolygonHelper(bestPoint, ring)) {
        console.warn('Best point is outside polygon! Using first sample point fallback');
        // Use any sample point - they're all guaranteed to be inside
        return samplePoints[0];
      }

      return bestPoint;
    }

    function createAreaLabels() {
      if (!areaGeoJSON?.features) return;

      const labelFeatures = areaGeoJSON.features.map(feature => {
        const props = feature.properties;
        const areaCode = props?.area_code;

        // Calculate optimal label position using pole of inaccessibility
        const coords = feature.geometry?.coordinates?.[0];
        let labelCoord = [0, 0];

        if (coords && coords.length > 0) {
          labelCoord = findOptimalLabelPosition(coords); // Use default grid size of 40

          // Final safety check - ensure label is inside polygon
          if (!pointInPolygonHelper(labelCoord, coords)) {
            console.error(`${areaCode}: Label position is OUTSIDE polygon! Attempting to find valid position...`);

            // Try to find ANY point inside the polygon from our samples
            const samplePoints = generateSamplePoints(coords, 50);
            if (samplePoints.length > 0) {
              // Use the first valid sample point we can find
              labelCoord = samplePoints[Math.floor(samplePoints.length / 2)];
              console.log(`${areaCode}: Using fallback sample point at [${labelCoord[0].toFixed(2)}, ${labelCoord[1].toFixed(2)}]`);
            } else {
              console.error(`${areaCode}: Could not find any valid points inside polygon!`);
            }
          }
        }

        return {
          type: 'Feature',
          properties: {
            area_code: areaCode,
            qnh: props.qnh,
            hasSplit: props.hasSplit,
            splitCount: props.splitCount
          },
          geometry: {
            type: 'Point',
            coordinates: labelCoord
          }
        };
      });

      const labelFC = {
        type: 'FeatureCollection',
        features: labelFeatures
      };

      if (map.getSource('area-labels')) {
        map.getSource('area-labels').setData(labelFC);
      } else {
        map.addSource('area-labels', { type: 'geojson', data: labelFC });
        map.addLayer({
          id: 'areas-label',
          type: 'symbol',
          source: 'area-labels',
          layout: {
            'text-field': [
              'format',
              ['to-string', ['coalesce', ['get', 'qnh'], '']],
              { 'font-scale': 1.0 },
              '\n',
              ['concat', 'AREA ', ['slice', ['get', 'area_code'], 5]],
              { 'font-scale': 0.7, 'text-color': '#c40000' }
            ],
            'text-font': ['Noto Sans Regular'],
            'text-size': 18,
            'text-allow-overlap': true,
            'text-ignore-placement': true,
            'symbol-z-order': 'source'
          },
          paint: {
            'text-halo-color': '#fff',
            'text-halo-width': 1.2
          }
        });
      }
    }

    function applyAreaQnhToPolygons() {
      if (!areaGeoJSON?.features) return;
      const qnhMap = areaQnhMap || {};

      areaGeoJSON.features.forEach((feature) => {
        const code = (feature.properties?.area_code || '').toUpperCase();
        const entry = qnhMap[code];
        const splits = areaSplits[code];

        // Hide main QNH if this area has splits
        if (splits?.length) {
          feature.properties.qnh = null; // Hide main QNH
          feature.properties.hasSplit = true;
          feature.properties.splitCount = splits.length;
        } else {
          feature.properties.qnh = entry ? entry.qnh : null;
          feature.properties.hasSplit = false;
          feature.properties.splitCount = 0;
        }
      });

      const source = map.getSource('areas');
      if (source?.setData) {
        source.setData(areaGeoJSON);
      }

      // Update labels with new QNH data
      createAreaLabels();
    }

    function fitToAreas(geojson) {
      const features = geojson?.features;
      if (!features?.length || !map?.fitBounds) return;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      const processCoord = (coord) => {
        if (!Array.isArray(coord) || coord.length < 2) return;
        const [x, y] = coord;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      };

      const walk = (coords) => {
        if (!Array.isArray(coords)) return;
        if (typeof coords[0] === 'number') {
          processCoord(coords);
          return;
        }
        coords.forEach(walk);
      };

      features.forEach(f => walk(f.geometry?.coordinates));
      
      if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return;

      const bounds = new maplibregl.LngLatBounds([minX, minY], [maxX, maxY]);
      map.fitBounds(bounds, { padding: 24, maxZoom: 6, duration: 400 });
    }

    function startQNHLoop() {
      fetchAndDrawQNH();
      setInterval(fetchAndDrawQNH, 15 * 60 * 1000);
    }

    async function fetchAndDrawQNH() {
      const validityBox = document.getElementById('validity');
      try {
        validityBox.textContent = 'Fetching QNH data...';
        
        const res = await fetch(QNH_WORKER_URL + '?t=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.text();

        const text = sanitizeHTML(raw);
        const parsed = parseQNHText(text);
        
        areaQnhMap = parsed.areaQnhMap;
        areaSplits = parsed.areaSplits;
        
        await ensureNavIndex();
        applyAreaQnhToPolygons();
        drawSplitLines();

        const v = parsed.validIssued;
        const areaCount = Object.keys(parsed.areaQnhMap || {}).length;
        const totalAreas = areaGeoJSON?.features?.length || '?';
        const splitCount = Object.keys(parsed.areaSplits || {}).length;
        
        validityBox.textContent = v
          ? `Valid: ${v.valid} | Issued: ${v.issued} | Areas: ${areaCount}/${totalAreas}${splitCount ? ` (${splitCount} split)` : ''}`
          : `Areas: ${areaCount}/${totalAreas}${splitCount ? ` (${splitCount} split)` : ''}`;
          
        showSuccess(`QNH data updated successfully (${areaCount} areas, ${splitCount} with splits)`);
      } catch (err) {
        console.error('Failed to fetch/parse QNH:', err);
        validityBox.textContent = 'Failed to fetch QNH data';
        showWarning('QNH fetch failed - latest values unavailable. Will retry in 15 minutes.');
      }
    }

    function sanitizeHTML(html) {
      return html
        .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
        .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
        .replace(/<br\s*\/?>/gi, '\n')
        .replace(/<\/(p|div|li|h\d|section)>/gi, '\n')
        .replace(/<[^>]+>/g, ' ')
        .replace(/&nbsp;/g, ' ')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/[ \t]+\n/g, '\n')
        .replace(/\n[ \t]+/g, '\n')
        .replace(/\n{3,}/g, '\n\n')
        .trim();
    }

    function parseQNHText(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const blocks = [];
      let current = null;

      for (const line of lines) {
        const m = line.match(/^(?:AREA|Area)\s*(\d+)\s*:(.*)$/);
        if (m) {
          if (current) blocks.push(current);
          current = { area: `AREA-${m[1]}`, lines: [] };
          const rest = m[2]?.trim();
          if (rest) current.lines.push(rest);
          continue;
        }
        if (/^Valid:/i.test(line) && current) {
          blocks.push(current);
          current = null;
          continue;
        }
        if (current) current.lines.push(line);
      }
      if (current) blocks.push(current);

      const areaQnhMapLocal = {};
      const areaSplitsLocal = {};

      for (const b of blocks) {
        const txt = b.lines.join(' ');
        const matches = [...txt.matchAll(/\b(\d{4})\b/g)].map(m => Number(m[1]));
        const qnh = matches.find(n => n >= 900 && n <= 1050) ?? null;
        if (qnh) areaQnhMapLocal[b.area] = { qnh };

        const rules = [];

        const betweenRegex = /BETWEEN\s+([^,]+?)\s+AND\s+([^,]+?)\s+(\d{4})(?=[^\d]|$)/gi;
        let match;
        while ((match = betweenRegex.exec(txt)) !== null) {
          rules.push({
            type: 'between',
            lhs: match[1].replace(/[.,;]+$/g, '').trim(),
            rhs: match[2].replace(/[.,;]+$/g, '').trim(),
            qnh: Number(match[3])
          });
        }

        const ofRegex = /\b(NW|NE|SW|SE|N|S|E|W)\s+OF\s+([^,]+?)\s+(\d{4})(?=[^\d]|$)/gi;
        while ((match = ofRegex.exec(txt)) !== null) {
          rules.push({
            type: 'of',
            dir: match[1].toUpperCase(),
            lhs: match[2].replace(/[.,;]+$/g, '').trim(),
            qnh: Number(match[3])
          });
        }

        const restRegex = /\bREST\s+(\d{4})(?=[^\d]|$)/gi;
        while ((match = restRegex.exec(txt)) !== null) {
          rules.push({
            type: 'rest',
            qnh: Number(match[1])
          });
        }

        if (rules.length) {
          areaSplitsLocal[b.area] = rules;
        }
      }

      const validAll = [...text.matchAll(/Valid:\s*([^\n]*?)(?=Issued:|\n|$)/gi)];
      const issuedAll = [...text.matchAll(/Issued:\s*([^\n]*)/gi)];
      const validIssued = (validAll.length && issuedAll.length)
        ? { valid: validAll.at(-1)[1].trim(), issued: issuedAll.at(-1)[1].trim() }
        : null;

      return { areaQnhMap: areaQnhMapLocal, areaSplits: areaSplitsLocal, validIssued };
    }

    function ensureNavIndex() {
      if (!navIndexPromise) navIndexPromise = fetchNavIndex();
      return navIndexPromise;
    }

    async function fetchNavIndex() {
      try {
        const res = await fetch(NAV_INDEX_URL + '?t=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error(`Nav index HTTP ${res.status}`);
        const xmlText = await res.text();
        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        navPointMap = {};

        const points = doc.querySelectorAll('Point[Name]');
        points.forEach((node) => {
          const name = node.getAttribute('Name');
          const raw = node.textContent?.trim();
          const coord = parseAirspacePoint(raw);
          if (name && coord) navPointMap[name.toUpperCase()] = coord;
        });

        const airports = doc.querySelectorAll('Airport[ICAO], Airport[Name], Airport[FullName], Airport[Position]');
        airports.forEach((node) => {
          const pos = node.getAttribute('Position') || node.textContent?.trim();
          const coord = parseAirspacePoint(pos);
          if (!coord) return;
          
          const icao = node.getAttribute('ICAO');
          const name = node.getAttribute('Name');
          const full = node.getAttribute('FullName');
          [icao, name, full].forEach(alias => {
            if (alias) navPointMap[alias.toUpperCase()] = coord;
          });
        });

        console.log(`Loaded ${Object.keys(navPointMap).length} navigation points`);
        return navPointMap;
      } catch (err) {
        console.error('Failed to load nav index:', err);
        showWarning('Could not load navigation index - split line reference points may not display.');
        return navPointMap;
      }
    }

    function parseAirspacePoint(raw) {
      if (!raw) return null;
      const parts = raw.split(/(?=[+-]\d)/).filter(Boolean);
      if (parts.length !== 2) return null;
      const lat = dmsStringToDecimal(parts[0]);
      const lon = dmsStringToDecimal(parts[1]);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return [lon, lat];
    }

    function dmsStringToDecimal(valStr) {
      if (!valStr) return NaN;
      const sign = valStr.trim().startsWith('-') ? -1 : 1;
      const num = Math.abs(parseFloat(valStr));
      const deg = Math.floor(num / 10000);
      const rem = num - deg * 10000;
      const min = Math.floor(rem / 100);
      const sec = rem - min * 100;
      return sign * (deg + min / 60 + sec / 3600);
    }

    function resolveTokenToCoord(token) {
      if (!token) return null;
      const trimmed = token.trim();
      
      const patterns = [
        /^(\d{1,2})([NS])(\d{1,3})([EW])$/i,
        /^(\d{1,2})(\d{2})([NS])(\d{1,3})(\d{2})([EW])$/i
      ];
      
      for (const pattern of patterns) {
        const m = trimmed.match(pattern);
        if (m) {
          const hasMin = m.length > 5;
          const latDeg = Number(m[1]);
          const latMin = hasMin ? Number(m[2]) : 0;
          const lonDeg = hasMin ? Number(m[4]) : Number(m[3]);
          const lonMin = hasMin ? Number(m[5]) : 0;
          const latDir = hasMin ? m[3] : m[2];
          const lonDir = hasMin ? m[6] : m[4];
          
          const lat = (latDir.toUpperCase() === 'S' ? -1 : 1) * (latDeg + latMin / 60);
          const lon = (lonDir.toUpperCase() === 'W' ? -1 : 1) * (lonDeg + lonMin / 60);
          return { coord: [lon, lat], name: trimmed.toUpperCase() };
        }
      }
      
      const lookup = navPointMap[trimmed.toUpperCase()];
      return lookup ? { coord: lookup, name: trimmed.toUpperCase() } : null;
    }

    function tokenizeSplitSide(sideText) {
      const skip = new Set(['N', 'S', 'E', 'W', 'NE', 'NW', 'SE', 'SW', 'OF', 'TO', 'FROM']);
      return sideText
        .split(/[\/\s]+/)
        .map(t => t.replace(/[.,;]+$/g, '').trim())
        .filter(t => t && !skip.has(t.toUpperCase()));
    }

    // Helper function to generate sample points within a polygon
    function generateSamplePoints(ring, gridSize = 20) {
      if (!ring || ring.length < 3) return [];

      // Find bounding box
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      ring.forEach(([x, y]) => {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      });

      const width = maxX - minX;
      const height = maxY - minY;
      const stepX = width / gridSize;
      const stepY = height / gridSize;

      const points = [];
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          const x = minX + i * stepX;
          const y = minY + j * stepY;
          const point = [x, y];

          // Check if point is inside polygon
          if (pointInPolygonHelper(point, ring)) {
            points.push(point);
          }
        }
      }

      return points;
    }

    function pointInPolygonHelper(point, ring) {
      const [x, y] = point;
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const [xi, yi] = ring[i];
        const [xj, yj] = ring[j];
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function calculateCentroidOfPoints(points) {
      if (!points || points.length === 0) return [0, 0];
      let sumX = 0, sumY = 0;
      points.forEach(([x, y]) => {
        sumX += x;
        sumY += y;
      });
      return [sumX / points.length, sumY / points.length];
    }

    // Determine if a point is on the specified directional side of a line
    function isPointOnDirectionSideOfLine(point, lineCoords, direction) {
      if (!lineCoords || lineCoords.length < 2) return false;

      const dir = direction.toUpperCase();

      // Calculate the centroid/midpoint of the line for reference
      let lineCenterX = 0, lineCenterY = 0;
      lineCoords.forEach(coord => {
        lineCenterX += coord[0];
        lineCenterY += coord[1];
      });
      lineCenterX /= lineCoords.length;
      lineCenterY /= lineCoords.length;

      // Use a hybrid approach: geographic direction relative to line center
      // plus cross product for more accurate boundary detection
      const pointX = point[0];
      const pointY = point[1];

      // For cardinal directions, use simple geographic comparison
      if (dir === 'E') {
        // East of line: point longitude > line center longitude
        return pointX > lineCenterX;
      } else if (dir === 'W') {
        // West of line: point longitude < line center longitude
        return pointX < lineCenterX;
      } else if (dir === 'N') {
        // North of line: point latitude > line center latitude
        return pointY > lineCenterY;
      } else if (dir === 'S') {
        // South of line: point latitude < line center latitude
        return pointY < lineCenterY;
      } else if (dir === 'NE') {
        // Northeast: both conditions
        return pointX > lineCenterX && pointY > lineCenterY;
      } else if (dir === 'NW') {
        return pointX < lineCenterX && pointY > lineCenterY;
      } else if (dir === 'SE') {
        return pointX > lineCenterX && pointY < lineCenterY;
      } else if (dir === 'SW') {
        return pointX < lineCenterX && pointY < lineCenterY;
      }

      // Fallback for unknown directions
      return true;
    }

    // Calculate cross product to determine which side of a line a point is on
    function calculateLineCross(point, lineCoords) {
      if (!lineCoords || lineCoords.length < 2) return 0;

      const p1 = lineCoords[0];
      const p2 = lineCoords[lineCoords.length - 1];
      const dx = p2[0] - p1[0];
      const dy = p2[1] - p1[1];

      // Cross product: positive = left side, negative = right side (when looking from p1 to p2)
      const cross = (point[0] - p1[0]) * dy - (point[1] - p1[1]) * dx;
      return cross;
    }

    function isPointAfterLine(point, lineCoords) {
      return calculateLineCross(point, lineCoords) > 0;
    }

    function isPointBeforeLine(point, lineCoords) {
      return calculateLineCross(point, lineCoords) < 0;
    }

    // Calculate distance from a point to a line segment
    function distanceToSegment(point, segStart, segEnd) {
      const [px, py] = point;
      const [x1, y1] = segStart;
      const [x2, y2] = segEnd;

      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSquared = dx * dx + dy * dy;

      if (lengthSquared === 0) {
        // Segment is a point
        return Math.hypot(px - x1, py - y1);
      }

      // Calculate projection parameter
      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
      t = Math.max(0, Math.min(1, t)); // Clamp to segment

      // Calculate closest point on segment
      const closestX = x1 + t * dx;
      const closestY = y1 + t * dy;

      return Math.hypot(px - closestX, py - closestY);
    }

    function drawSplitLines() {
      const solidLineFeatures = [];
      const dashedLineFeatures = [];
      const pointFeatures = [];
      const splitLabelFeatures = [];

      const seenPoint = new Set();
      const addPoint = (area, p) => {
        const key = `${area}|${p.name}|${p.coord[0].toFixed(6)}|${p.coord[1].toFixed(6)}`;
        if (seenPoint.has(key)) return;
        seenPoint.add(key);
        pointFeatures.push({
          type: 'Feature',
          properties: { area, name: p.name },
          geometry: { type: 'Point', coordinates: p.coord }
        });
      };

      const buildLineCoords = (sideText) => {
        const tokens = tokenizeSplitSide(sideText);
        const coords = [];
        tokens.forEach(tok => {
          const resolved = resolveTokenToCoord(tok);
          if (resolved) {
            coords.push(resolved);
          } else {
            console.warn('Unresolved split token:', tok);
          }
        });
        return coords;
      };

      const getAreaRing = (areaCode) => {
        const feature = areaGeoJSON?.features?.find(f => 
          f.properties?.area_code?.toUpperCase() === areaCode.toUpperCase()
        );
        return feature?.geometry?.coordinates?.[0] || null;
      };

      const pointInPolygon = (point, ring) => {
        const [x, y] = point;
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const [xi, yi] = ring[i];
          const [xj, yj] = ring[j];
          const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      };

      const extendToBoundary = (point, direction, ring) => {
        if (!ring || !point || !direction) return null;
        
        const far = [
          point[0] + direction[0] * 1000,
          point[1] + direction[1] * 1000
        ];
        
        let closest = null;
        let minDist = Infinity;
        
        for (let i = 0; i < ring.length - 1; i++) {
          const a = ring[i];
          const b = ring[i + 1];
          const hit = lineIntersection(point, far, a, b);
          if (hit) {
            const dist = Math.hypot(hit[0] - point[0], hit[1] - point[1]);
            if (dist > 0.0001 && dist < minDist) {
              minDist = dist;
              closest = hit;
            }
          }
        }
        
        return closest;
      };

      const lineIntersection = (p1, p2, p3, p4) => {
        const x1 = p1[0], y1 = p1[1];
        const x2 = p2[0], y2 = p2[1];
        const x3 = p3[0], y3 = p3[1];
        const x4 = p4[0], y4 = p4[1];
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-10) return null;
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
          return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
        }
        
        return null;
      };

      const clipPolyline = (coords, ring) => {
        const solid = [];
        const dashed = [];

        for (let i = 0; i < coords.length - 1; i++) {
          const p1 = coords[i];
          const p2 = coords[i + 1];

          const p1Inside = pointInPolygon(p1, ring);
          const p2Inside = pointInPolygon(p2, ring);

          if (p1Inside && p2Inside) {
            solid.push([p1, p2]);
          } else if (!p1Inside && !p2Inside) {
            let crossings = [];
            for (let j = 0; j < ring.length - 1; j++) {
              const hit = lineIntersection(p1, p2, ring[j], ring[j + 1]);
              if (hit) {
                const dist = Math.hypot(hit[0] - p1[0], hit[1] - p1[1]);
                crossings.push({ point: hit, dist });
              }
            }

            if (crossings.length >= 2) {
              crossings.sort((a, b) => a.dist - b.dist);
              dashed.push([p1, crossings[0].point]);
              solid.push([crossings[0].point, crossings[1].point]);
              dashed.push([crossings[1].point, p2]);
            } else {
              dashed.push([p1, p2]);
            }
          } else {
            let crossing = null;
            for (let j = 0; j < ring.length - 1; j++) {
              const hit = lineIntersection(p1, p2, ring[j], ring[j + 1]);
              if (hit) {
                crossing = hit;
                break;
              }
            }

            if (crossing) {
              if (p1Inside) {
                solid.push([p1, crossing]);
                dashed.push([crossing, p2]);
              } else {
                dashed.push([p1, crossing]);
                solid.push([crossing, p2]);
              }
            } else {
              if (p1Inside || p2Inside) {
                solid.push([p1, p2]);
              } else {
                dashed.push([p1, p2]);
              }
            }
          }
        }

        return { solid, dashed };
      };

      const getCentroid = (ring) => {
        if (!ring || ring.length < 3) return null;
        let sumX = 0, sumY = 0;
        const count = ring.length - 1; // Exclude closing point
        for (let i = 0; i < count; i++) {
          sumX += ring[i][0];
          sumY += ring[i][1];
        }
        return [sumX / count, sumY / count];
      };

      Object.entries(areaSplits || {}).forEach(([areaCode, rules]) => {
        const ring = getAreaRing(areaCode);
        if (!ring) return;

        // Calculate centroid of the main area for potential label placement
        const areaCentroid = getCentroid(ring);

        (rules || []).forEach((rule, idx) => {
          if (rule.type === 'between') {
            const lhsPts = buildLineCoords(rule.lhs);
            const rhsPts = buildLineCoords(rule.rhs);
            
            lhsPts.forEach(p => addPoint(areaCode, p));
            rhsPts.forEach(p => addPoint(areaCode, p));
            
            if (lhsPts.length >= 2 && ring) {
              const coords = lhsPts.map(p => p.coord);

              const firstDir = [
                coords[0][0] - coords[1][0],
                coords[0][1] - coords[1][1]
              ];
              const firstLen = Math.hypot(firstDir[0], firstDir[1]);
              const firstNorm = firstLen > 0 ? [firstDir[0] / firstLen, firstDir[1] / firstLen] : [0, 0];
              const startBoundary = extendToBoundary(coords[0], firstNorm, ring);

              const lastIdx = coords.length - 1;
              const lastDir = [
                coords[lastIdx][0] - coords[lastIdx - 1][0],
                coords[lastIdx][1] - coords[lastIdx - 1][1]
              ];
              const lastLen = Math.hypot(lastDir[0], lastDir[1]);
              const lastNorm = lastLen > 0 ? [lastDir[0] / lastLen, lastDir[1] / lastLen] : [0, 0];
              const endBoundary = extendToBoundary(coords[lastIdx], lastNorm, ring);

              const extendedCoords = [
                ...(startBoundary ? [startBoundary] : []),
                ...coords,
                ...(endBoundary ? [endBoundary] : [])
              ];

              const { solid, dashed } = clipPolyline(extendedCoords, ring);
              
              solid.forEach(seg => {
                solidLineFeatures.push({
                  type: 'Feature',
                  properties: { area: areaCode, qnh: rule.qnh, type: 'between', side: 'lhs', idx },
                  geometry: { type: 'LineString', coordinates: seg }
                });
              });
              
              dashed.forEach(seg => {
                dashedLineFeatures.push({
                  type: 'Feature',
                  properties: { area: areaCode, qnh: rule.qnh, type: 'between', side: 'lhs', idx },
                  geometry: { type: 'LineString', coordinates: seg }
                });
              });
            }
            
            if (rhsPts.length >= 2 && ring) {
              const coords = rhsPts.map(p => p.coord);

              const firstDir = [
                coords[0][0] - coords[1][0],
                coords[0][1] - coords[1][1]
              ];
              const firstLen = Math.hypot(firstDir[0], firstDir[1]);
              const firstNorm = firstLen > 0 ? [firstDir[0] / firstLen, firstDir[1] / firstLen] : [0, 0];
              const startBoundary = extendToBoundary(coords[0], firstNorm, ring);

              const lastIdx = coords.length - 1;
              const lastDir = [
                coords[lastIdx][0] - coords[lastIdx - 1][0],
                coords[lastIdx][1] - coords[lastIdx - 1][1]
              ];
              const lastLen = Math.hypot(lastDir[0], lastDir[1]);
              const lastNorm = lastLen > 0 ? [lastDir[0] / lastLen, lastDir[1] / lastLen] : [0, 0];
              const endBoundary = extendToBoundary(coords[lastIdx], lastNorm, ring);

              const extendedCoords = [
                ...(startBoundary ? [startBoundary] : []),
                ...coords,
                ...(endBoundary ? [endBoundary] : [])
              ];

              const { solid, dashed } = clipPolyline(extendedCoords, ring);
              
              solid.forEach(seg => {
                solidLineFeatures.push({
                  type: 'Feature',
                  properties: { area: areaCode, qnh: rule.qnh, type: 'between', side: 'rhs', idx },
                  geometry: { type: 'LineString', coordinates: seg }
                });
              });
              
              dashed.forEach(seg => {
                dashedLineFeatures.push({
                  type: 'Feature',
                  properties: { area: areaCode, qnh: rule.qnh, type: 'between', side: 'rhs', idx },
                  geometry: { type: 'LineString', coordinates: seg }
                });
              });
            }
          }

          if (rule.type === 'of') {
            const pts = buildLineCoords(rule.lhs);
            pts.forEach(p => addPoint(areaCode, p));

            if (pts.length >= 2 && ring) {
              const coords = pts.map(p => p.coord);

              const firstDir = [
                coords[0][0] - coords[1][0],
                coords[0][1] - coords[1][1]
              ];
              const firstLen = Math.hypot(firstDir[0], firstDir[1]);
              const firstNorm = firstLen > 0 ? [firstDir[0] / firstLen, firstDir[1] / firstLen] : [0, 0];
              const startBoundary = extendToBoundary(coords[0], firstNorm, ring);

              const lastIdx = coords.length - 1;
              const lastDir = [
                coords[lastIdx][0] - coords[lastIdx - 1][0],
                coords[lastIdx][1] - coords[lastIdx - 1][1]
              ];
              const lastLen = Math.hypot(lastDir[0], lastDir[1]);
              const lastNorm = lastLen > 0 ? [lastDir[0] / lastLen, lastDir[1] / lastLen] : [0, 0];
              const endBoundary = extendToBoundary(coords[lastIdx], lastNorm, ring);

              const extendedCoords = [
                ...(startBoundary ? [startBoundary] : []),
                ...coords,
                ...(endBoundary ? [endBoundary] : [])
              ];

              const { solid, dashed } = clipPolyline(extendedCoords, ring);
              
              solid.forEach(seg => {
                solidLineFeatures.push({
                  type: 'Feature',
                  properties: { area: areaCode, qnh: rule.qnh, type: 'of', dir: rule.dir || '', idx },
                  geometry: { type: 'LineString', coordinates: seg }
                });
              });
              
              dashed.forEach(seg => {
                dashedLineFeatures.push({
                  type: 'Feature',
                  properties: { area: areaCode, qnh: rule.qnh, type: 'of', dir: rule.dir || '', idx },
                  geometry: { type: 'LineString', coordinates: seg }
                });
              });
            }
          }
        });

        // Create labels for split zones using proper zone centroid calculation
        // First, collect all split lines for this area
        const splitLines = [];
        rules.forEach((rule, ruleIdx) => {
          if (rule.type === 'between') {
            const lhsPts = buildLineCoords(rule.lhs || '');
            const rhsPts = buildLineCoords(rule.rhs || '');

            if (lhsPts.length >= 2 && rhsPts.length >= 2) {
              splitLines.push({
                lhsCoords: lhsPts.map(p => p.coord),
                rhsCoords: rhsPts.map(p => p.coord),
                rule: rule,
                ruleIdx: ruleIdx
              });
            }
          } else if (rule.type === 'of') {
            const pts = buildLineCoords(rule.lhs || '');
            if (pts.length >= 2) {
              splitLines.push({
                coords: pts.map(p => p.coord),
                rule: rule,
                ruleIdx: ruleIdx
              });
            }
          }
        });

        // Generate sample points within the area polygon
        const samplePoints = generateSamplePoints(ring, 50);

        // For each rule with a QNH, determine which zone it belongs to and calculate centroid
        rules.forEach((rule, ruleIdx) => {
          if (!rule.qnh) return;

          let zonePoints = [];

          if (rule.type === 'of' && rule.dir) {
            // Find the split line for this rule
            const splitLine = splitLines.find(sl => sl.ruleIdx === ruleIdx);
            if (splitLine && splitLine.coords && splitLine.coords.length >= 2) {
              // Filter points that are on the correct side of the line
              zonePoints = samplePoints.filter(pt => {
                return isPointOnDirectionSideOfLine(pt, splitLine.coords, rule.dir);
              });

              console.log(`${areaCode} rule ${ruleIdx} (${rule.dir} OF): Found ${zonePoints.length} points in zone (QNH ${rule.qnh})`);
            }
          } else if (rule.type === 'between') {
            // Find the BETWEEN rule with both lines
            const splitLine = splitLines.find(sl => sl.ruleIdx === ruleIdx);

            if (splitLine && splitLine.lhsCoords && splitLine.rhsCoords) {
              // A point is "between" two lines if it's on the inside/facing side of both lines
              // First, determine which sides of the lines face each other

              // Get midpoints of both lines
              const lhsMid = [
                (splitLine.lhsCoords[0][0] + splitLine.lhsCoords[splitLine.lhsCoords.length - 1][0]) / 2,
                (splitLine.lhsCoords[0][1] + splitLine.lhsCoords[splitLine.lhsCoords.length - 1][1]) / 2
              ];
              const rhsMid = [
                (splitLine.rhsCoords[0][0] + splitLine.rhsCoords[splitLine.rhsCoords.length - 1][0]) / 2,
                (splitLine.rhsCoords[0][1] + splitLine.rhsCoords[splitLine.rhsCoords.length - 1][1]) / 2
              ];

              // Calculate which side of each line the other line is on
              const lhsCrossToRhs = calculateLineCross(rhsMid, splitLine.lhsCoords);
              const rhsCrossToLhs = calculateLineCross(lhsMid, splitLine.rhsCoords);

              // Now filter points that are on the same side as the facing sides
              zonePoints = samplePoints.filter(pt => {
                const lhsCross = calculateLineCross(pt, splitLine.lhsCoords);
                const rhsCross = calculateLineCross(pt, splitLine.rhsCoords);

                // Point is between if it's on the same side of LHS as RHS is,
                // AND on the same side of RHS as LHS is
                const sameSideAsRhs = (lhsCross > 0) === (lhsCrossToRhs > 0);
                const sameSideAsLhs = (rhsCross > 0) === (rhsCrossToLhs > 0);

                return sameSideAsRhs && sameSideAsLhs;
              });

              console.log(`${areaCode} rule ${ruleIdx} (BETWEEN): Found ${zonePoints.length} points in zone (QNH ${rule.qnh})`);
            }
          } else if (rule.type === 'rest') {
            // REST zone contains points not in any other zone
            zonePoints = samplePoints.filter(pt => {
              // Check if point is NOT in any specifically defined zone
              for (let i = 0; i < rules.length; i++) {
                if (i === ruleIdx) continue; // Skip the REST rule itself

                const otherRule = rules[i];
                const otherLine = splitLines.find(sl => sl.ruleIdx === i);

                if (otherRule.type === 'of' && otherRule.dir && otherLine && otherLine.coords) {
                  if (isPointOnDirectionSideOfLine(pt, otherLine.coords, otherRule.dir)) {
                    return false; // Point is in another zone
                  }
                } else if (otherRule.type === 'between' && otherLine && otherLine.lhsCoords && otherLine.rhsCoords) {
                  // Use the same improved logic as BETWEEN zone detection
                  const lhsMid = [
                    (otherLine.lhsCoords[0][0] + otherLine.lhsCoords[otherLine.lhsCoords.length - 1][0]) / 2,
                    (otherLine.lhsCoords[0][1] + otherLine.lhsCoords[otherLine.lhsCoords.length - 1][1]) / 2
                  ];
                  const rhsMid = [
                    (otherLine.rhsCoords[0][0] + otherLine.rhsCoords[otherLine.rhsCoords.length - 1][0]) / 2,
                    (otherLine.rhsCoords[0][1] + otherLine.rhsCoords[otherLine.rhsCoords.length - 1][1]) / 2
                  ];

                  const lhsCrossToRhs = calculateLineCross(rhsMid, otherLine.lhsCoords);
                  const rhsCrossToLhs = calculateLineCross(lhsMid, otherLine.rhsCoords);

                  const lhsCross = calculateLineCross(pt, otherLine.lhsCoords);
                  const rhsCross = calculateLineCross(pt, otherLine.rhsCoords);

                  const sameSideAsRhs = (lhsCross > 0) === (lhsCrossToRhs > 0);
                  const sameSideAsLhs = (rhsCross > 0) === (rhsCrossToLhs > 0);

                  if (sameSideAsRhs && sameSideAsLhs) {
                    return false; // Point is in the between zone
                  }
                }
              }
              return true; // Point is not in any other zone
            });

            console.log(`${areaCode} rule ${ruleIdx} (REST): Found ${zonePoints.length} points in zone (QNH ${rule.qnh})`);
          }

          // Calculate centroid of zone points
          if (zonePoints.length > 0) {
            console.log(`${areaCode} rule ${ruleIdx}: Processing ${zonePoints.length} zone points for QNH ${rule.qnh}`);

            if (zonePoints.length < 10) {
              console.warn(`${areaCode} rule ${ruleIdx}: Very few points (${zonePoints.length}) in zone for QNH ${rule.qnh}. Zone detection may be incorrect.`);
            }
            // Find the point that's furthest from ALL boundaries (red area boundary + green split lines)
            // This is crucial - we need to push labels away from split lines, not just polygon edges
            let bestPoint = zonePoints[0];
            let maxMinDist = 0;

            // Sample points to find the best interior point
            const sampleStep = Math.max(1, Math.floor(zonePoints.length / 100)); // More aggressive sampling

            for (let i = 0; i < zonePoints.length; i += sampleStep) {
              const pt = zonePoints[i];
              let minDistToBoundary = Infinity;

              // Check distance to red area boundary
              for (let j = 0; j < ring.length - 1; j++) {
                const dist = distanceToSegment(pt, ring[j], ring[j + 1]);
                minDistToBoundary = Math.min(minDistToBoundary, dist);
              }

              // Check distance to relevant green split lines (weighted more heavily)
              if (rule.type === 'of' && rule.dir) {
                const splitLine = splitLines.find(sl => sl.ruleIdx === ruleIdx);
                if (splitLine && splitLine.coords) {
                  for (let j = 0; j < splitLine.coords.length - 1; j++) {
                    const dist = distanceToSegment(pt, splitLine.coords[j], splitLine.coords[j + 1]);
                    // Weight split line distance 2x to push labels away from them
                    minDistToBoundary = Math.min(minDistToBoundary, dist * 0.5);
                  }
                }
              } else if (rule.type === 'between') {
                const splitLine = splitLines.find(sl => sl.ruleIdx === ruleIdx);
                if (splitLine && splitLine.lhsCoords && splitLine.rhsCoords) {
                  for (let j = 0; j < splitLine.lhsCoords.length - 1; j++) {
                    const dist = distanceToSegment(pt, splitLine.lhsCoords[j], splitLine.lhsCoords[j + 1]);
                    // Weight split line distance 2x to push labels away from them
                    minDistToBoundary = Math.min(minDistToBoundary, dist * 0.5);
                  }
                  for (let j = 0; j < splitLine.rhsCoords.length - 1; j++) {
                    const dist = distanceToSegment(pt, splitLine.rhsCoords[j], splitLine.rhsCoords[j + 1]);
                    // Weight split line distance 2x to push labels away from them
                    minDistToBoundary = Math.min(minDistToBoundary, dist * 0.5);
                  }
                }
              } else if (rule.type === 'rest') {
                // For REST zones, check distance to ALL split lines in this area
                splitLines.forEach(sl => {
                  if (sl.coords) {
                    for (let j = 0; j < sl.coords.length - 1; j++) {
                      const dist = distanceToSegment(pt, sl.coords[j], sl.coords[j + 1]);
                      // Weight split line distance 2x to push labels away from them
                      minDistToBoundary = Math.min(minDistToBoundary, dist * 0.5);
                    }
                  }
                  if (sl.lhsCoords) {
                    for (let j = 0; j < sl.lhsCoords.length - 1; j++) {
                      const dist = distanceToSegment(pt, sl.lhsCoords[j], sl.lhsCoords[j + 1]);
                      // Weight split line distance 2x to push labels away from them
                      minDistToBoundary = Math.min(minDistToBoundary, dist * 0.5);
                    }
                  }
                  if (sl.rhsCoords) {
                    for (let j = 0; j < sl.rhsCoords.length - 1; j++) {
                      const dist = distanceToSegment(pt, sl.rhsCoords[j], sl.rhsCoords[j + 1]);
                      // Weight split line distance 2x to push labels away from them
                      minDistToBoundary = Math.min(minDistToBoundary, dist * 0.5);
                    }
                  }
                });
              }

              // Keep track of the point with maximum distance to nearest boundary
              if (minDistToBoundary > maxMinDist) {
                maxMinDist = minDistToBoundary;
                bestPoint = pt;
              }
            }

            // Use best point if found, otherwise use middle sample point (guaranteed inside)
            const finalPoint = maxMinDist > 0 ? bestPoint : zonePoints[Math.floor(zonePoints.length / 2)];

            console.log(`${areaCode} rule ${ruleIdx}: Placing QNH ${rule.qnh} label at [${finalPoint[0].toFixed(2)}, ${finalPoint[1].toFixed(2)}] (maxMinDist: ${maxMinDist.toFixed(4)})`);

            splitLabelFeatures.push({
              type: 'Feature',
              properties: {
                area: areaCode,
                qnh: rule.qnh,
                ruleType: rule.type,
                ruleIndex: ruleIdx,
                direction: rule.dir || ''
              },
              geometry: {
                type: 'Point',
                coordinates: finalPoint
              }
            });
          } else if (areaCentroid) {
            // Fallback to simple offset if no sample points found
            let labelCoord = [...areaCentroid];
            const offsetX = (ruleIdx - (rules.length - 1) / 2) * 1.2;
            const offsetY = (ruleIdx - (rules.length - 1) / 2) * 0.8;
            labelCoord = [areaCentroid[0] + offsetX, areaCentroid[1] + offsetY];

            splitLabelFeatures.push({
              type: 'Feature',
              properties: {
                area: areaCode,
                qnh: rule.qnh,
                ruleType: rule.type,
                ruleIndex: ruleIdx,
                direction: rule.dir || ''
              },
              geometry: {
                type: 'Point',
                coordinates: labelCoord
              }
            });
          }
        });

        // For split zones, DO NOT apply automatic offsets
        // The offset validation only checks the full polygon, not individual zones
        // This could push labels into wrong zones
        // The pole-of-inaccessibility algorithm already separates labels naturally
        console.log(`${areaCode}: Skipping automatic offsets for split zones to prevent cross-zone label placement`);
      });

      const solidLineFC = { type: 'FeatureCollection', features: solidLineFeatures };
      const dashedLineFC = { type: 'FeatureCollection', features: dashedLineFeatures };
      const pointFC = { type: 'FeatureCollection', features: pointFeatures };
      const splitLabelFC = { type: 'FeatureCollection', features: splitLabelFeatures };

      // Update or create split QNH labels
      if (map.getSource('qnh-split-labels')) {
        map.getSource('qnh-split-labels').setData(splitLabelFC);
      } else {
        map.addSource('qnh-split-labels', { type: 'geojson', data: splitLabelFC });
        map.addLayer({
          id: 'qnh-split-labels',
          type: 'symbol',
          source: 'qnh-split-labels',
          layout: {
            'text-field': ['to-string', ['get', 'qnh']],
            'text-font': ['Noto Sans Regular'],
            'text-size': 18,
            'text-allow-overlap': true,
            'text-ignore-placement': true,
            'symbol-z-order': 'source'
          },
          paint: {
            'text-color': '#1f9e45',
            'text-halo-color': '#fff',
            'text-halo-width': 1.2
          }
        });
      }

      if (map.getSource('qnh-split-lines')) {
        map.getSource('qnh-split-lines').setData(solidLineFC);
      } else {
        map.addSource('qnh-split-lines', { type: 'geojson', data: solidLineFC });
        map.addLayer({
          id: 'qnh-split-lines',
          type: 'line',
          source: 'qnh-split-lines',
          paint: {
            'line-color': '#1f9e45',
            'line-width': 1.5
          }
        });
      }

      if (map.getSource('qnh-split-lines-dashed')) {
        map.getSource('qnh-split-lines-dashed').setData(dashedLineFC);
      } else {
        map.addSource('qnh-split-lines-dashed', { type: 'geojson', data: dashedLineFC });
        map.addLayer({
          id: 'qnh-split-lines-dashed',
          type: 'line',
          source: 'qnh-split-lines-dashed',
          paint: {
            'line-color': '#1f9e45',
            'line-width': 1.5,
            'line-dasharray': [3, 3]
          }
        });
      }

      if (map.getSource('qnh-split-points')) {
        map.getSource('qnh-split-points').setData(pointFC);
      } else {
        map.addSource('qnh-split-points', { type: 'geojson', data: pointFC });
        map.addLayer({
          id: 'qnh-split-points',
          type: 'symbol',
          source: 'qnh-split-points',
          layout: {
            'text-field': '×',
            'text-size': 16,
            'text-allow-overlap': true,
            'symbol-z-order': 'source'
          },
          paint: {
            'text-color': '#000000',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1.5
          }
        });
        map.addLayer({
          id: 'qnh-split-point-labels',
          type: 'symbol',
          source: 'qnh-split-points',
          layout: {
            'text-field': ['get', 'name'],
            'text-size': 9,
            'text-offset': [0, 1.2],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#111111',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1.5
          }
        });
      }

      console.log(`Drew ${solidLineFeatures.length} solid lines, ${dashedLineFeatures.length} dashed lines, ${splitLabelFeatures.length} split labels, and ${pointFeatures.length} reference points`);
    }

  </script>
</body>
</html>