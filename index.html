<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Area QNH Map</title>
  <link rel="stylesheet" href="./maplibre-gl.css" />
  <style>
    :root {
      --panel: #f7f7f7;
      --stroke: #d6d6d6;
      --label-red: #c40000;
      --warn-bg: #fff4d7;
      --warn-border: #f0c96a;
      --warn-text: #7a5a05;
    }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: #ffffff;
      color: #111;
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
    }
    header {
      padding: 14px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--panel);
      border-bottom: 1px solid var(--stroke);
      gap: 8px;
      flex-wrap: wrap;
    }
    .title h1 { margin: 0; font-size: 1.1rem; }
    .title .sub { margin: 0; font-size: 0.9rem; color: #555; }
    #validity {
      margin-left: auto;
      font-size: 0.9rem;
      color: #444;
      white-space: nowrap;
    }
    main {
      padding: 16px;
      display: flex;
      flex-direction: column;
    }
    #warning {
      margin-bottom: 12px;
      padding: 10px 12px;
      border: 1px solid var(--warn-border);
      border-radius: 10px;
      background: var(--warn-bg);
      color: var(--warn-text);
      font-size: 0.95rem;
      display: none;
    }
    #map {
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      min-height: 0;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.18);
      background: #edf1f5;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Area QNH Map</h1>
      <p class="sub">Replica of the BOM Area QNH Map removed from the new BOM website.</p>
    </div>
    <div id="validity">Fetching QNH</div>
  </header>

  <main>
    <div id="warning" role="status" aria-live="polite"></div>
    <div id="map" aria-label="Area QNH map"></div>
  </main>

  <script src="./maplibre-gl.js"></script>
  <script>
    const warningBox = document.getElementById('warning');
    const showWarning = (message) => {
      if (!message) return;
      warningBox.textContent = message;
      warningBox.style.display = 'block';
    };

    const QNH_WORKER_URL = 'https://areaqnh.therealleviticus.workers.dev/';
    const NAV_INDEX_URL = 'https://airspace.therealleviticus.workers.dev/';

    // Inline GAF area polygons so the page works from file:// or any host
    const AREA_DATA = {"type":"FeatureCollection","features":[{"type":"Feature","properties":{"area_code":"AREA-20","name":"QNH_AREA_20","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[148.383333,-32.75],[150.0,-29.0],[154.703056,-28.043611],[155.0,-28.833333],[152.666667,-34.333333],[151.177222,-33.946111],[150.988333,-33.924444],[149.651944,-33.409444],[148.383333,-32.75]]]}},{"type":"Feature","properties":{"area_code":"AREA-21","name":"QNH_AREA_21","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[146.924722,-36.195278],[148.383333,-32.75],[149.651944,-33.409444],[150.988333,-33.924444],[151.177222,-33.946111],[152.666667,-34.333333],[150.870556,-37.881111],[149.976111,-37.503889],[146.924722,-36.195278]]]}},{"type":"Feature","properties":{"area_code":"AREA-22","name":"QNH_AREA_22","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[141.0,-29.0],[150.0,-29.0],[148.383333,-32.75],[146.924722,-36.195278],[141.0,-33.65],[141.0,-29.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-24","name":"QNH_AREA_24","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[152.666667,-34.333333],[155.0,-28.833333],[163.0,-28.5],[163.0,-31.333333],[152.666667,-34.333333]]]}},{"type":"Feature","properties":{"area_code":"AREA-30","name":"QNH_AREA_30","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[141.0,-33.65],[146.924722,-36.195278],[149.976111,-37.503889],[150.870556,-37.881111],[150.2,-39.57],[142.8575,-39.57],[141.0,-39.57],[141.0,-33.65]]]}},{"type":"Feature","properties":{"area_code":"AREA-40","name":"QNH_AREA_40","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[147.820833,-23.156111],[152.864444,-23.155833],[154.703056,-28.043611],[150.0,-29.0],[148.183333,-23.566667],[147.820833,-23.156111]]]}},{"type":"Feature","properties":{"area_code":"AREA-41","name":"QNH_AREA_41","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[138.0,-26.0],[138.0,-23.156111],[147.820833,-23.156111],[148.183333,-23.566667],[150.0,-29.0],[141.0,-29.0],[141.0,-26.0],[138.0,-26.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-43","name":"QNH_AREA_43","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[138.0,-23.156111],[138.0,-19.0],[143.533333,-18.3],[147.820833,-23.156111],[138.0,-23.156111]]]}},{"type":"Feature","properties":{"area_code":"AREA-44","name":"QNH_AREA_44","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[143.533333,-18.3],[148.0,-18.283333],[152.864444,-23.155833],[147.820833,-23.156111],[143.533333,-18.3]]]}},{"type":"Feature","properties":{"area_code":"AREA-45","name":"QNH_AREA_45","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[141.0,-9.833333],[141.033333,-9.616667],[142.083333,-9.261667],[142.805,-9.323889],[143.875,-9.133333],[144.233333,-9.4],[144.089167,-9.942778],[144.026667,-11.5],[144.072222,-11.725],[144.0,-12.0],[147.607778,-16.995833],[148.0,-18.283333],[143.533333,-18.3],[138.0,-19.0],[138.0,-14.0],[141.0,-9.833333]]]}},{"type":"Feature","properties":{"area_code":"AREA-50","name":"QNH_AREA_50","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[134.5,-35.5],[135.372222,-34.686667],[137.716667,-32.5],[141.0,-33.65],[141.0,-39.57],[134.5,-35.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-51","name":"QNH_AREA_51","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[135.0,-30.0],[141.0,-29.0],[141.0,-33.65],[137.716667,-32.5],[135.0,-30.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-52","name":"QNH_AREA_52","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-26.0],[138.0,-26.0],[141.0,-26.0],[141.0,-29.0],[135.0,-30.0],[129.0,-30.0],[129.0,-26.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-53","name":"QNH_AREA_53","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-30.0],[135.0,-30.0],[137.716667,-32.5],[135.372222,-34.686667],[134.5,-35.5],[131.0,-32.5],[129.0,-33.0],[129.0,-30.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-60","name":"QNH_AREA_60","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.5,-27.5],[118.0,-27.5],[119.0,-32.25],[113.5,-33.5],[112.5,-27.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-61","name":"QNH_AREA_61","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[119.0,-32.25],[118.0,-27.5],[123.5,-27.5],[123.618333,-30.84],[119.0,-32.25]]]}},{"type":"Feature","properties":{"area_code":"AREA-62","name":"QNH_AREA_62","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[123.618333,-30.84],[129.0,-30.0],[129.0,-33.0],[123.5,-35.0],[123.618333,-30.84]]]}},{"type":"Feature","properties":{"area_code":"AREA-63","name":"QNH_AREA_63","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[113.5,-33.5],[119.0,-32.25],[123.618333,-30.84],[123.5,-35.0],[116.0,-36.25],[113.5,-33.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-64","name":"QNH_AREA_64","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[123.5,-23.88],[129.0,-23.88],[129.0,-30.0],[123.618333,-30.84],[123.5,-27.5],[123.5,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-65","name":"QNH_AREA_65","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.096944,-23.88],[115.984722,-23.88],[118.0,-27.5],[112.5,-27.5],[112.096944,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-66","name":"QNH_AREA_66","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[115.984722,-23.88],[123.5,-23.88],[123.5,-27.5],[118.0,-27.5],[115.984722,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-68","name":"QNH_AREA_68","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.0,-23.0],[113.0,-21.0],[117.0,-18.0],[120.0,-18.0],[123.5,-20.5],[123.5,-23.88],[115.984722,-23.88],[112.096944,-23.88],[112.0,-23.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-69","name":"QNH_AREA_69","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[117.0,-18.0],[124.0,-14.0],[126.148056,-13.751667],[127.5,-14.0],[128.416667,-14.833333],[129.0,-14.879444],[129.0,-20.0],[123.5,-20.5],[120.0,-18.0],[117.0,-18.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-70","name":"QNH_AREA_70","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[142.8575,-39.57],[150.2,-39.57],[149.0,-43.0],[147.5,-44.5],[145.0,-44.0],[142.8575,-39.57]]]}},{"type":"Feature","properties":{"area_code":"AREA-80","name":"QNH_AREA_80","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-9.409722],[141.0,-9.833333],[138.0,-14.0],[138.0,-19.0],[129.0,-15.884444],[129.0,-14.879444],[129.0,-9.409722]]]}},{"type":"Feature","properties":{"area_code":"AREA-83","name":"QNH_AREA_83","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[123.5,-20.5],[129.0,-20.0],[129.0,-23.88],[123.5,-23.88],[123.5,-20.5]]]}},{"type":"Feature","properties":{"area_code":"AREA-84","name":"QNH_AREA_84","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-20.0],[129.0,-15.884444],[138.0,-19.0],[138.0,-23.156111],[129.0,-22.25],[129.0,-20.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-85","name":"QNH_AREA_85","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[129.0,-23.88],[129.0,-22.25],[138.0,-23.156111],[138.0,-26.0],[129.0,-26.0],[129.0,-23.88]]]}},{"type":"Feature","properties":{"area_code":"AREA-86","name":"QNH_AREA_86","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[124.774444,-10.9125],[126.833333,-9.333333],[129.0,-9.409722],[129.0,-14.879444],[128.416667,-14.833333],[127.5,-14.0],[126.148056,-13.751667],[124.0,-14.0],[124.774444,-10.9125]]]}},{"type":"Feature","properties":{"area_code":"AREA-87","name":"QNH_AREA_87","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[112.0,-18.0],[118.0,-15.0],[124.0,-14.0],[117.0,-18.0],[112.0,-18.0]]]}},{"type":"Feature","properties":{"area_code":"AREA-88","name":"QNH_AREA_88","qnh":null},"geometry":{"type":"Polygon","coordinates":[[[110.0,-19.0],[112.0,-18.0],[117.0,-18.0],[113.0,-21.0],[110.0,-19.0]]]}}]};

    let areaGeoJSON = null;
    let areaQnhMap = {};
    let areaSplits = {};
    let navPointMap = {};
    let navIndexPromise = null;
    let zoneFeatureIdCounter = 1;
    let selectedZoneId = null;
    let zoneClickBound = false;

    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
        sources: {
          osm: {
            type: 'raster',
            tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
            tileSize: 256,
            attribution: ' OpenStreetMap contributors'
          }
        },
        layers: [{ id: 'osm-base', type: 'raster', source: 'osm' }],
        "text-font": ["Noto Sans Regular"]
      },
      center: [134.5, -25.5],
      zoom: 3.6
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-left');

    map.on('error', (e) => {
      const { resourceType, sourceId } = e || {};
      if (resourceType === 'glyphs') {
        showWarning('Map labels may be missing because glyphs could not be loaded (possible offline or blocked network).');
      }
      if (resourceType === 'tile' && sourceId === 'osm') {
        showWarning('Base map tiles failed to load. Polygons will still render, check connectivity or tile access.');
      }
    });

    map.on('load', () => {
      loadAreas();
      ensureNavIndex();
      startQNHLoop();
    });

    async function loadAreas() {
      const geojson = JSON.parse(JSON.stringify(AREA_DATA));
      geojson.features.forEach((f, i) => f.id = i + 1);
      areaGeoJSON = geojson;

      map.addSource('areas', { type: 'geojson', data: geojson });

      map.addLayer({
        id: 'areas-fill',
        type: 'fill',
        source: 'areas',
        paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.30 }
      });

      map.addLayer({
        id: 'areas-line',
        type: 'line',
        source: 'areas',
        paint: { 'line-color': '#d40000', 'line-width': 2 }
      });

      map.addLayer({
        id: 'areas-label',
        type: 'symbol',
        source: 'areas',
        layout: {
          'text-field': [
            'format',
            ['to-string', ['coalesce', ['get', 'qnh'], '']],
            { 'font-scale': 1.0, 'text-color': '#000' },
            '\n',
            ['concat', 'AREA ', ['slice', ['get', 'area_code'], 5]],
            { 'font-scale': 0.7, 'text-color': '#c40000' }
          ],
          'text-font': ['Noto Sans Regular'],
          'text-size': 18,
          'text-allow-overlap': true,
          'text-ignore-placement': true,
          'text-variable-anchor': ['center'],
          'symbol-z-order': 'source'
        },
        paint: {
          'text-halo-color': '#fff',
          'text-halo-width': 1.2
        }
      });

      applyAreaQnhToPolygons();
      fitToAreas(geojson);
    }

    function applyAreaQnhToPolygons() {
      if (!areaGeoJSON || !areaGeoJSON.features) return;
      const qnhMap = areaQnhMap || {};

      areaGeoJSON.features.forEach((feature) => {
        const code = (feature.properties?.area_code || '').toUpperCase();
        const entry = qnhMap[code];
        feature.properties.qnh = entry ? entry.qnh : null;
      });

      const source = map.getSource && map.getSource('areas');
      if (source && source.setData) {
        source.setData(areaGeoJSON);
      }
    }

    function fitToAreas(geojson) {
      const features = geojson?.features;
      if (!features || !features.length || !map || typeof map.fitBounds !== 'function') return;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      const add = (coord) => {
        if (!Array.isArray(coord) || coord.length < 2) return;
        const [x, y] = coord;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      };

      const walk = (coords) => {
        if (!Array.isArray(coords)) return;
        if (typeof coords[0] === 'number') {
          add(coords);
          return;
        }
        coords.forEach(walk);
      };

      features.forEach(f => walk(f.geometry?.coordinates));
      if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return;

      const bounds = new maplibregl.LngLatBounds([minX, minY], [maxX, maxY]);
      map.fitBounds(bounds, { padding: 24, maxZoom: 6, duration: 400 });
    }

    function startQNHLoop() {
      fetchAndDrawQNH();
      setInterval(fetchAndDrawQNH, 15 * 60 * 1000);
    }

    async function fetchAndDrawQNH() {
      const validityBox = document.getElementById('validity');
      try {
        const res = await fetch(QNH_WORKER_URL + '?t=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.text();

        let text = raw
          .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
          .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
          .replace(/<br\s*\/?/gi, '\n')
          .replace(/<\/(p|div|li|h\d|section)>/gi, '\n')
          .replace(/<[^>]+>/g, ' ')
          .replace(/&nbsp;/g, ' ')
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/[ \t]+\n/g, '\n')
          .replace(/\n[ \t]+/g, '\n')
          .replace(/\n{3,}/g, '\n\n')
          .trim();

        const parsed = parseQNHText(text);
        areaQnhMap = parsed.areaQnhMap;
        areaSplits = parsed.areaSplits;
        await ensureNavIndex();
        applyAreaQnhToPolygons();
        drawGreenLines();

        const v = parsed.validIssued;
        const areaCount = Object.keys(parsed.areaQnhMap || {}).length;
        const totalAreas = areaGeoJSON?.features?.length || '?';
        validityBox.textContent = v
          ? `Valid: ${v.valid}  Issued: ${v.issued}  Areas ${areaCount}/${totalAreas}`
          : `Validity unknown  Areas ${areaCount}/${totalAreas}`;
      } catch (err) {
        console.error('Failed to fetch/parse QNH', err);
        document.getElementById('validity').textContent = 'Failed to fetch QNH';
        showWarning('QNH fetch failed  latest values unavailable.');
      }
    }

    function parseQNHText(text) {
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const blocks = [];
      let current = null;
      for (const line of lines) {
        const m = line.match(/^(?:AREA|Area)\s*(\d+)\s*:(.*)$/);
        if (m) {
          if (current) blocks.push(current);
          current = { area: `AREA-${m[1]}`, lines: [] };
          const rest = m[2]?.trim();
          if (rest) current.lines.push(rest);
          continue;
        }
        if (/^Valid:/i.test(line) && current) {
          blocks.push(current);
          current = null;
          continue;
        }
        if (current) current.lines.push(line);
      }
      if (current) blocks.push(current);

      const areaQnhMapLocal = {};
      const areaSplitsLocal = {};
      for (const b of blocks) {
        const txt = b.lines.join(' ');
        const matches = [...txt.matchAll(/\b(\d{4})\b/g)].map(m => Number(m[1]));
        const qnh = matches.find(n => n >= 900 && n <= 1050) ?? null;
        if (qnh) areaQnhMapLocal[b.area] = { qnh };

        const rules = [];

        const betweenRegex = /BETWEEN\s+([^,]+?)\s+AND\s+([^,]+?)\s+(\d{4})(?=[^\d]|$)/gi;
        let match;
        while ((match = betweenRegex.exec(txt)) !== null) {
          rules.push({
            type: 'between',
            raw: match[0],
            lhs: match[1].replace(/[.,;]+$/g, '').trim(),
            rhs: match[2].replace(/[.,;]+$/g, '').trim(),
            qnh: Number(match[3])
          });
        }

        const ofRegex = /\b(NW|NE|SW|SE|N|S|E|W)\s+OF\s+([^,]+?)\s+(\d{4})(?=[^\d]|$)/gi;
        while ((match = ofRegex.exec(txt)) !== null) {
          rules.push({
            type: 'of',
            raw: match[0],
            dir: match[1].toUpperCase(),
            lhs: match[2].replace(/[.,;]+$/g, '').trim(),
            rhs: '',
            qnh: Number(match[3])
          });
        }

        const restRegex = /\bREST\s+(\d{4})(?=[^\d]|$)/gi;
        while ((match = restRegex.exec(txt)) !== null) {
          rules.push({
            type: 'rest',
            raw: match[0],
            qnh: Number(match[1])
          });
        }

        if (rules.length) {
          areaSplitsLocal[b.area] = rules;
        }
      }

      const validAll = [...text.matchAll(/Valid:\s*([^\n]*?)(?=Issued:|\n|$)/gi)];
      const issuedAll = [...text.matchAll(/Issued:\s*([^\n]*)/gi)];
      const validIssued = (validAll.length && issuedAll.length)
        ? { valid: validAll.at(-1)[1].trim(), issued: issuedAll.at(-1)[1].trim() }
        : null;

      return { areaQnhMap: areaQnhMapLocal, areaSplits: areaSplitsLocal, validIssued };
    }

    function ensureNavIndex() {
      if (!navIndexPromise) navIndexPromise = fetchNavIndex();
      return navIndexPromise;
    }

    async function fetchNavIndex() {
      try {
        const res = await fetch(NAV_INDEX_URL + '?t=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error(`Nav index HTTP ${res.status}`);
        const xmlText = await res.text();
        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        navPointMap = {};

        const points = doc.querySelectorAll('Point[Name]');
        points.forEach((node) => {
          const name = node.getAttribute('Name');
          const raw = node.textContent?.trim();
          const coord = parseAirspacePoint(raw);
          if (name && coord) navPointMap[name.toUpperCase()] = coord;
        });

        const airports = doc.querySelectorAll('Airport[ICAO], Airport[Name], Airport[FullName], Airport[Position]');
        airports.forEach((node) => {
          const pos = node.getAttribute('Position') || node.textContent?.trim();
          const coord = parseAirspacePoint(pos);
          if (!coord) return;
          const icao = node.getAttribute('ICAO');
          const name = node.getAttribute('Name');
          const full = node.getAttribute('FullName');
          [icao, name, full].forEach(alias => {
            if (alias) navPointMap[alias.toUpperCase()] = coord;
          });
        });

        return navPointMap;
      } catch (err) {
        console.error('Failed to load nav index', err);
        showWarning('Could not load nav index for green split lines.');
        return navPointMap;
      }
    }

    function parseAirspacePoint(raw) {
      if (!raw) return null;
      const parts = raw.split(/(?=[+-]\d)/).filter(Boolean);
      if (parts.length !== 2) return null;
      const lat = dmsStringToDecimal(parts[0]);
      const lon = dmsStringToDecimal(parts[1]);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return [lon, lat];
    }

    function dmsStringToDecimal(valStr) {
      if (!valStr) return NaN;
      const sign = valStr.trim().startsWith('-') ? -1 : 1;
      const num = Math.abs(parseFloat(valStr));
      const deg = Math.floor(num / 10000);
      const rem = num - deg * 10000;
      const min = Math.floor(rem / 100);
      const sec = rem - min * 100;
      return sign * (deg + min / 60 + sec / 3600);
    }

    function parseLatLonToken(token) {
      const m = token.match(/^(\d{1,2})([NS])(\d{1,3})([EW])$/i);
      if (!m) return null;
      const latDeg = Number(m[1]);
      const lonDeg = Number(m[3]);
      const lat = (m[2].toUpperCase() === 'S' ? -1 : 1) * latDeg;
      const lon = (m[4].toUpperCase() === 'W' ? -1 : 1) * lonDeg;
      return [lon, lat];
    }

    function parseLatLonTokenWithMin(token) {
      const m = token.match(/^(\d{1,2})(\d{2})([NS])(\d{1,3})(\d{2})([EW])$/i);
      if (!m) return null;
      const latDeg = Number(m[1]);
      const latMin = Number(m[2]);
      const lonDeg = Number(m[4]);
      const lonMin = Number(m[5]);
      const lat = (m[3].toUpperCase() === 'S' ? -1 : 1) * (latDeg + latMin / 60);
      const lon = (m[6].toUpperCase() === 'W' ? -1 : 1) * (lonDeg + lonMin / 60);
      return [lon, lat];
    }

    function resolveTokenToCoord(token) {
      if (!token) return null;
      const trimmed = token.trim();
      const coordFromToken = parseLatLonToken(trimmed);
      if (coordFromToken) return { coord: coordFromToken, name: trimmed.toUpperCase() };
      const coordWithMin = parseLatLonTokenWithMin(trimmed);
      if (coordWithMin) return { coord: coordWithMin, name: trimmed.toUpperCase() };
      const lookup = navPointMap[trimmed.toUpperCase()];
      return lookup ? { coord: lookup, name: trimmed.toUpperCase() } : null;
    }

    function tokenizeSplitSide(sideText) {
      const skip = new Set(['N', 'S', 'E', 'W', 'NE', 'NW', 'SE', 'SW', 'OF', 'TO', 'FROM']);
      return sideText
        .split(/[\/\s]+/)
        .map(t => t.replace(/[.,;]+$/g, '').trim())
        .filter(t => t && !skip.has(t.toUpperCase()));
    }

    const EXTEND_SPLIT_LINE_START = true;
    const EXTEND_SPLIT_LINE_END = true;

    const EPS = 1e-10;
    const MIN_RING_AREA = 1e-9;

    function pointInPolygon(point, ring) {
      const x = point[0], y = point[1];
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][0], yi = ring[i][1];
        const xj = ring[j][0], yj = ring[j][1];
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / ((yj - yi) || EPS) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function pointInPolygonWithHoles(point, polyObj) {
      if (!polyObj) return false;
      const outer = polyObj.outer || polyObj;
      const holes = polyObj.holes || [];
      if (!pointInPolygon(point, outer)) return false;
      return !holes.some(h => pointInPolygon(point, h));
    }

    function ringSignedArea(ring) {
      if (!ring || ring.length < 3) return 0;
      let area = 0;
      for (let i = 0; i < ring.length - 1; i++) {
        const [x1, y1] = ring[i];
        const [x2, y2] = ring[i + 1];
        area += x1 * y2 - x2 * y1;
      }
      return area / 2;
    }

    function ensureClosedRing(ring) {
      if (!ring || !ring.length) return [];
      const closed = ring.slice();
      const first = closed[0];
      const last = closed[closed.length - 1];
      if (Math.abs(first[0] - last[0]) > EPS || Math.abs(first[1] - last[1]) > EPS) {
        closed.push([first[0], first[1]]);
      }
      return closed;
    }

    function sanitizeRing(ring) {
      const closed = ensureClosedRing(ring || []);
      if (closed.length < 4) return [];
      const dedup = [closed[0]];
      for (let i = 1; i < closed.length; i++) {
        const p = closed[i];
        const prev = dedup[dedup.length - 1];
        if (Math.hypot(p[0] - prev[0], p[1] - prev[1]) > 1e-12) dedup.push(p);
      }
      const finalRing = ensureClosedRing(dedup);
      const area = Math.abs(ringSignedArea(finalRing));
      return (finalRing.length >= 4 && area > MIN_RING_AREA) ? finalRing : [];
    }

    function polygonKey(ring) {
      const oriented = orientRing(sanitizeRing(ring), false);
      if (!oriented.length) return '';
      const pts = oriented.slice(0, -1); // drop closing duplicate for key
      let start = 0;
      for (let i = 1; i < pts.length; i++) {
        const a = pts[i], b = pts[start];
        if (a[0] < b[0] - 1e-9 || (Math.abs(a[0] - b[0]) < 1e-9 && a[1] < b[1] - 1e-9)) start = i;
      }
      const ordered = [];
      for (let i = 0; i < pts.length; i++) {
        ordered.push(pts[(start + i) % pts.length]);
      }
      return ordered.map(p => `${p[0].toFixed(6)},${p[1].toFixed(6)}`).join('|');
    }

    function polylineSideMatches(pt, coords, samplePoint) {
      if (!coords || coords.length < 2 || !samplePoint) return false;
      const sp = samplePoint;
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coords[i];
        const b = coords[i + 1];
        const keepPositive = signedSide(sp, a, b) >= 0;
        const side = signedSide(pt, a, b);
        if (keepPositive ? side < -EPS : side > EPS) return false;
      }
      return true;
    }

    function orientRing(ring, clockwise = false) {
      const closed = ensureClosedRing(ring);
      const area = ringSignedArea(closed);
      const isClockwise = area < 0;
      if (clockwise === isClockwise) return closed;
      const body = closed.slice(0, -1).reverse();
      return ensureClosedRing(body);
    }

    function safeInteriorPoint(ring) {
      if (!ring || ring.length < 3) return null;
      const best = bestInteriorPoint(ring, null);
      if (best) return best;
      const c = polygonCentroid(ring);
      return pushInsidePolygon(c, ring, c);
    }

    // Build planar faces from segments covering an area ring
    // Faces/planar subdivision removed; only green line rendering remains

    function signedSide(p, a, b) {
      return (b[0] - a[0]) * (p[1] - a[1]) - (b[1] - a[1]) * (p[0] - a[0]);
    }

    function intersectSegmentWithLine(p1, p2, a, b) {
      const r = [p2[0] - p1[0], p2[1] - p1[1]];
      const s = [b[0] - a[0], b[1] - a[1]];
      const denom = r[0] * s[1] - r[1] * s[0];
      if (Math.abs(denom) < EPS) return null;
      const qp = [a[0] - p1[0], a[1] - p1[1]];
      const t = (qp[0] * s[1] - qp[1] * s[0]) / denom;
      if (t < -EPS || t > 1 + EPS) return null;
      return [p1[0] + t * r[0], p1[1] + t * r[1]];
    }

    function segIntersect(p, p2, q, q2) {
      const r = [p2[0] - p[0], p2[1] - p[1]];
      const s = [q2[0] - q[0], q2[1] - q[1]];
      const denom = r[0] * s[1] - r[1] * s[0];
      if (Math.abs(denom) < EPS) return null;
      const qp = [q[0] - p[0], q[1] - p[1]];
      const t = (qp[0] * s[1] - qp[1] * s[0]) / denom;
      const u = (qp[0] * r[1] - qp[1] * r[0]) / denom;
      if (t < -EPS || t > 1 + EPS || u < -EPS || u > 1 + EPS) return null;
      const pt = [p[0] + t * r[0], p[1] + t * r[1]];
      return { t, u, pt };
    }

    function rayIntersectPolygon(origin, dir, ring) {
      const far = [origin[0] + dir[0] * 1e6, origin[1] + dir[1] * 1e6];
      let bestT = Infinity;
      let best = null;
      for (let i = 0; i < ring.length - 1; i++) {
        const a = ring[i];
        const b = ring[i + 1];
        const hit = segIntersect(origin, far, a, b);
        if (!hit) continue;

        // Tightened threshold so we do not skip legitimate border hits near the start point
        if (hit.t > 1e-12 && hit.t < bestT) {
          bestT = hit.t;
          best = hit.pt;
        }
      }
      return best;
    }

    function clipSegmentToPolygon(p1, p2, ring) {
      const pts = [{ t: 0, pt: p1 }, { t: 1, pt: p2 }];
      for (let i = 0; i < ring.length - 1; i++) {
        const a = ring[i];
        const b = ring[i + 1];
        const hit = segIntersect(p1, p2, a, b);
        if (hit) {
          const tClamped = Math.max(0, Math.min(1, hit.t));
          pts.push({ t: tClamped, pt: hit.pt });
        }
      }

      pts.sort((x, y) => x.t - y.t);
      const dedup = [];
      for (const p of pts) {
        if (!dedup.length || Math.abs(dedup[dedup.length - 1].t - p.t) > 1e-7) {
          dedup.push(p);
        }
      }

      const segs = [];
      for (let i = 0; i < dedup.length - 1; i++) {
        const a = dedup[i].pt;
        const b = dedup[i + 1].pt;
        const mid = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        if (pointInPolygon(mid, ring)) {
          segs.push([a, b]);
        }
      }
      return segs;
    }

    function clipPolylineToPolygon(coords, ring) {
      const out = [];
      for (let i = 0; i < coords.length - 1; i++) {
        const p1 = coords[i];
        const p2 = coords[i + 1];
        const segs = clipSegmentToPolygon(p1, p2, ring);
        segs.forEach(seg => out.push(seg));
      }
      return out;
    }

    function normalise(v) {
      const m = Math.hypot(v[0], v[1]);
      if (m < EPS) return [0, 0];
      return [v[0] / m, v[1] / m];
    }

    function extendPolylineToBorders(coords, ring) {
      const extended = coords.slice();
      if (extended.length < 2) return extended;

      if (EXTEND_SPLIT_LINE_START) {
        const a = extended[0];
        const b = extended[1];
        const dir = normalise([a[0] - b[0], a[1] - b[1]]);
        const hit = rayIntersectPolygon(a, dir, ring);
        if (hit) extended.unshift(hit);
      }

      if (EXTEND_SPLIT_LINE_END) {
        const n = extended.length;
        const a = extended[n - 2];
        const b = extended[n - 1];
        const dir = normalise([b[0] - a[0], b[1] - a[1]]);
        const hit = rayIntersectPolygon(b, dir, ring);
        if (hit) extended.push(hit);
      }

      return extended;
    }

    function polygonCentroid(ring) {
      let area = 0;
      let cx = 0;
      let cy = 0;
      for (let i = 0; i < ring.length - 1; i++) {
        const [x0, y0] = ring[i];
        const [x1, y1] = ring[i + 1];
        const a = x0 * y1 - x1 * y0;
        area += a;
        cx += (x0 + x1) * a;
        cy += (y0 + y1) * a;
      }
      area *= 0.5;
      if (Math.abs(area) < EPS) {
        const xs = ring.map(p => p[0]);
        const ys = ring.map(p => p[1]);
        return [xs.reduce((s, v) => s + v, 0) / xs.length, ys.reduce((s, v) => s + v, 0) / ys.length];
      }
      cx /= (6 * area);
      cy /= (6 * area);
      return [cx, cy];
    }

    function pushInsidePolygon(candidate, ring, fallback) {
      if (pointInPolygon(candidate, ring)) return candidate;
      const steps = 20;
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const p = [candidate[0] + (fallback[0] - candidate[0]) * t, candidate[1] + (fallback[1] - candidate[1]) * t];
        if (pointInPolygon(p, ring)) return p;
      }
      return fallback;
    }

    function ringBounds(ring) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      ring.forEach(([x, y]) => {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      });
      return { minX, minY, maxX, maxY };
    }

    function getRingBBox(ring) {
      if (!ring || !ring.length) return { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
      return ringBounds(ring);
    }

    function pointInAnyPolygon(pt, polygons) {
      return polygons.some(poly => pointInPolygon(pt, poly));
    }

    function pointSegDist(p, a, b) {
      const vx = b[0] - a[0];
      const vy = b[1] - a[1];
      const wx = p[0] - a[0];
      const wy = p[1] - a[1];
      const c1 = vx * wx + vy * wy;
      const c2 = vx * vx + vy * vy;
      const t = c2 > EPS ? Math.max(0, Math.min(1, c1 / c2)) : 0;
      const px = a[0] + t * vx;
      const py = a[1] + t * vy;
      const dx = p[0] - px;
      const dy = p[1] - py;
      return Math.hypot(dx, dy);
    }

    function pointToPolygonDist(p, ring) {
      if (!ring || ring.length < 2) return Infinity;
      let minD = Infinity;
      for (let i = 0; i < ring.length - 1; i++) {
        const a = ring[i];
        const b = ring[i + 1];
        const d = pointSegDist(p, a, b);
        if (d < minD) minD = d;
      }
      return minD;
    }

    function pointToPolygonsDist(p, polys) {
      if (!polys || !polys.length) return Infinity;
      let best = Infinity;
      polys.forEach(poly => {
        const d = pointToPolygonDist(p, poly);
        if (d < best) best = d;
      });
      return best;
    }

    function bestInteriorPoint(ring, avoidPolys) {
      if (!ring || ring.length < 3) return null;
      const bounds = ringBounds(ring);
      const width = bounds.maxX - bounds.minX;
      const height = bounds.maxY - bounds.minY;
      const baseStep = Math.max(width, height) || 1;
      let best = null;
      let bestScore = -Infinity;

      const consider = (pt) => {
        if (!pointInPolygon(pt, ring)) return;
        if (avoidPolys && pointInAnyPolygon(pt, avoidPolys)) return;
        const distToRing = pointToPolygonDist(pt, ring);
        const distToAvoid = pointToPolygonsDist(pt, avoidPolys);
        const score = Math.min(distToRing, distToAvoid);
        if (score > bestScore + 1e-6) {
          bestScore = score;
          best = pt;
        }
      };

      consider(polygonCentroid(ring));

      const iterations = 5;
      for (let iter = 0; iter < iterations; iter++) {
        const step = baseStep / Math.pow(2, iter + 1);
        for (let x = bounds.minX; x <= bounds.maxX + EPS; x += step) {
          for (let y = bounds.minY; y <= bounds.maxY + EPS; y += step) {
            consider([x, y]);
          }
        }
      }

      if (best && (!avoidPolys || !pointInAnyPolygon(best, avoidPolys))) return best;
      return null;
    }

    function clipPolygonToPolygon(subjectRing, clipRing) {
      let output = ensureClosedRing(subjectRing);
      const clip = ensureClosedRing(clipRing);
      if (output.length < 3 || clip.length < 3) return [];

      const clipArea = ringSignedArea(clip);
      const clipCCW = clipArea > 0;

      for (let i = 0; i < clip.length - 1; i++) {
        const a = clip[i];
        const b = clip[i + 1];
        const keepPositive = (p) => {
          const side = signedSide(p, a, b);
          return clipCCW ? side >= -EPS : side <= EPS;
        };

        const input = output.slice();
        output = [];
        if (!input.length) break;

        for (let j = 0; j < input.length - 1; j++) {
          const current = input[j];
          const next = input[j + 1];
          const currentInside = keepPositive(current);
          const nextInside = keepPositive(next);

          if (currentInside && nextInside) {
            output.push(next);
          } else if (currentInside && !nextInside) {
            const hit = intersectSegmentWithLine(current, next, a, b);
            if (hit) output.push(hit);
          } else if (!currentInside && nextInside) {
            const hit = intersectSegmentWithLine(current, next, a, b);
            if (hit) output.push(hit);
            output.push(next);
          }
        }
        if (output.length) {
          const first = output[0];
          const last = output[output.length - 1];
          if (Math.abs(first[0] - last[0]) > EPS || Math.abs(first[1] - last[1]) > EPS) {
            output.push([first[0], first[1]]);
          }
        }
      }

      return output;
    }

    function clipPolygonWithLine(ring, a, b, keepPositive = true) {
      const closed = ensureClosedRing(ring);
      if (closed.length < 3) return [];
      const out = [];
      for (let i = 0; i < closed.length - 1; i++) {
        const p1 = closed[i];
        const p2 = closed[i + 1];
        const d1 = signedSide(p1, a, b);
        const d2 = signedSide(p2, a, b);
        const inside1 = keepPositive ? d1 >= -EPS : d1 <= EPS;
        const inside2 = keepPositive ? d2 >= -EPS : d2 <= EPS;

        if (inside1 && inside2) {
          out.push(p2);
        } else if (inside1 && !inside2) {
          const hit = intersectSegmentWithLine(p1, p2, a, b);
          if (hit) out.push(hit);
        } else if (!inside1 && inside2) {
          const hit = intersectSegmentWithLine(p1, p2, a, b);
          if (hit) out.push(hit);
          out.push(p2);
        }
      }

      if (out.length) {
        const first = out[0];
        const last = out[out.length - 1];
        if (Math.abs(first[0] - last[0]) > EPS || Math.abs(first[1] - last[1]) > EPS) {
          out.push([first[0], first[1]]);
        }
      }
      return out;
    }

    function clipPolygonToSideOfPolyline(ring, coords, samplePoint) {
      if (!coords || coords.length < 2 || !samplePoint) return [];
      let poly = ensureClosedRing(ring);
      const safeSample = pushInsidePolygon(samplePoint, ring, polygonCentroid(ring));
      for (let i = 0; i < coords.length - 1; i++) {
        const a = coords[i];
        const b = coords[i + 1];
        const keepPositive = signedSide(safeSample, a, b) >= 0;
        poly = clipPolygonWithLine(poly, a, b, keepPositive);
        if (!poly.length) break;
      }
      return poly;
    }

    function dirToVector(dir) {
      const d = (dir || '').toUpperCase();
      const dx = (d.includes('E') ? 1 : 0) - (d.includes('W') ? 1 : 0);
      const dy = (d.includes('N') ? 1 : 0) - (d.includes('S') ? 1 : 0);
      const v = normalise([dx, dy]);
      return (Math.abs(v[0]) < EPS && Math.abs(v[1]) < EPS) ? [1, 0] : v;
    }

    function midPointOfCoords(coords) {
      if (!coords || !coords.length) return null;
      const mid = coords[Math.floor(coords.length / 2)];
      return mid ? [mid[0], mid[1]] : null;
    }

    function ringsIntersect(r1, r2) {
      if (!r1 || !r2 || r1.length < 2 || r2.length < 2) return false;
      const a = ensureClosedRing(r1);
      const b = ensureClosedRing(r2);
      for (let i = 0; i < a.length - 1; i++) {
        const p1 = a[i], p2 = a[i + 1];
        for (let j = 0; j < b.length - 1; j++) {
          const q1 = b[j], q2 = b[j + 1];
          const hit = segIntersect(p1, p2, q1, q2);
          if (hit) return true;
        }
      }
      return false;
    }

    function ringTouchesOrInside(outer, ring) {
      const closedOuter = ensureClosedRing(outer);
      const closedRing = ensureClosedRing(ring);
      if (closedRing.some(pt => pointInPolygon(pt, closedOuter))) return true;
      if (ringsIntersect(closedOuter, closedRing)) return true;
      return false;
    }

    function bestInteriorPointWithPredicate(ring, avoidPolys, predicate) {
      if (!predicate) return bestInteriorPoint(ring, avoidPolys);
      if (!ring || ring.length < 3) return null;
      const bounds = ringBounds(ring);
      const width = bounds.maxX - bounds.minX;
      const height = bounds.maxY - bounds.minY;
      const baseStep = Math.max(width, height) || 1;
      let best = null;
      let bestScore = -Infinity;

      const consider = (pt) => {
        if (!pointInPolygon(pt, ring)) return;
        if (avoidPolys && pointInAnyPolygon(pt, avoidPolys)) return;
        if (!predicate(pt)) return;
        const distToRing = pointToPolygonDist(pt, ring);
        const distToAvoid = pointToPolygonsDist(pt, avoidPolys);
        const score = Math.min(distToRing, distToAvoid);
        if (score > bestScore + 1e-6) {
          bestScore = score;
          best = pt;
        }
      };

      consider(polygonCentroid(ring));

      const iterations = 5;
      for (let iter = 0; iter < iterations; iter++) {
        const step = baseStep / Math.pow(2, iter + 1);
        for (let x = bounds.minX; x <= bounds.maxX + EPS; x += step) {
          for (let y = bounds.minY; y <= bounds.maxY + EPS; y += step) {
            consider([x, y]);
          }
        }
      }

      return best;
    }

    function computeRestPolygons(ring, occupiedPolys) {
      const outer = sanitizeRing(ring);
      const holes = [];
      (occupiedPolys || []).forEach(poly => {
        const clean = sanitizeRing(poly);
        if (!clean.length) return;
        const clipped = clipPolygonToPolygon(clean, outer);
        const clippedClean = sanitizeRing(clipped);
        if (!clippedClean.length) return;
        const hole = orientRing(clippedClean, true);
        if (ringTouchesOrInside(outer, hole)) holes.push(hole);
      });

      const orientedOuter = orientRing(outer, false);

      const labelPoint = bestInteriorPointWithPredicate(
        orientedOuter,
        holes,
        (p) => !pointInAnyPolygon(p, holes)
      ) || polygonCentroid(orientedOuter);

      const polyObj = { outer: orientedOuter, holes };
      return { polys: [polyObj], labelPoint };
    }

    function findOpenPointInRing(ring, avoidPolys, fallback) {
      const centroid = polygonCentroid(ring);
      const base = fallback || centroid;
      const bounds = ringBounds(ring);
      const spanX = (bounds.maxX - bounds.minX) || 1;
      const spanY = (bounds.maxY - bounds.minY) || 1;
      const isFree = (pt) => pointInPolygon(pt, ring) && !pointInAnyPolygon(pt, avoidPolys || []);
      if (isFree(base)) return base;
      const radii = [0.1, 0.2, 0.35, 0.5, 0.75, 1.0, 1.3, 1.6];
      for (const r of radii) {
        for (let ang = 0; ang < 360; ang += 30) {
          const rad = ang * Math.PI / 180;
          const candidate = [
            base[0] + Math.cos(rad) * r * spanX,
            base[1] + Math.sin(rad) * r * spanY
          ];
          if (isFree(candidate)) return candidate;
        }
      }
      return null;
    }

    function buildSidePoints(sideText) {
      if (!sideText) return [];
      const toks = tokenizeSplitSide(sideText);
      const pts = [];
      toks.forEach(tok => {
        const resolved = resolveTokenToCoord(tok);
        if (resolved) pts.push(resolved);
        else console.warn('Split token unresolved', tok);
      });
      return pts;
    }

    function drawGreenLines() {
      const lineFeatures = [];
      const pointFeatures = [];
      const labelFeatures = [];
      const zoneLabelFeatures = [];
      const zoneFillFeatures = [];
      const zonePolygons = [];

      if (selectedZoneId !== null && map.getSource('qnh-zone-fills')) {
        if (map.removeFeatureState) {
          map.removeFeatureState({ source: 'qnh-zone-fills', id: selectedZoneId });
        } else {
          map.setFeatureState({ source: 'qnh-zone-fills', id: selectedZoneId }, { selected: false });
        }
        selectedZoneId = null;
      }
      zoneFeatureIdCounter = 1;

      const ensureSource = (id, data) => {
        if (map.getSource(id)) {
          map.getSource(id).setData(data);
        } else {
          map.addSource(id, { type: 'geojson', data });
        }
      };

      const seenPoint = new Set();
      const addPoint = (area, p) => {
        const key = `${area}|${p.name}|${p.coord[0].toFixed(6)}|${p.coord[1].toFixed(6)}`;
        if (seenPoint.has(key)) return;
        seenPoint.add(key);
        pointFeatures.push({
          type: 'Feature',
          properties: { area, name: p.name },
          geometry: { type: 'Point', coordinates: p.coord }
        });
      };

      const areaFeatureByCode = {};
      (areaGeoJSON?.features || []).forEach(f => {
        const code = f.properties?.area_code?.toUpperCase();
        if (code) areaFeatureByCode[code] = f;
      });

      Object.entries(areaSplits || {}).forEach(([areaCode, rules]) => {
        const areaFeature = areaFeatureByCode[areaCode.toUpperCase()];
        const ringRaw = areaFeature?.geometry?.coordinates?.[0];
        const ring = sanitizeRing(ringRaw);
        if (!ring.length) return;

        const splitLines = [];

        (rules || []).forEach((rule, idx) => {
          if (rule.type === 'between') {
            const lhsPts = buildSidePoints(rule.lhs);
            const rhsPts = buildSidePoints(rule.rhs);
            if (lhsPts.length >= 2) lhsPts.forEach(p => addPoint(areaCode, p));
            if (rhsPts.length >= 2) rhsPts.forEach(p => addPoint(areaCode, p));

            const lhsCoords = lhsPts.map(p => p.coord);
            const rhsCoords = rhsPts.map(p => p.coord);
            const lhsExt = extendPolylineToBorders(lhsCoords, ring);
            const rhsExt = extendPolylineToBorders(rhsCoords, ring);
            if (lhsExt.length < 2 || rhsExt.length < 2) return;

            const lhsClippedSegs = clipPolylineToPolygon(lhsExt, ring);
            const rhsClippedSegs = clipPolylineToPolygon(rhsExt, ring);
            lhsClippedSegs.forEach((seg) => {
              lineFeatures.push({
                type: 'Feature',
                properties: { area: areaCode, qnh: rule.qnh, type: 'between', side: 'lhs', idx },
                geometry: { type: 'LineString', coordinates: seg }
              });
              splitLines.push({ a: seg[0], b: seg[1] });
            });
            rhsClippedSegs.forEach((seg) => {
              lineFeatures.push({
                type: 'Feature',
                properties: { area: areaCode, qnh: rule.qnh, type: 'between', side: 'rhs', idx },
                geometry: { type: 'LineString', coordinates: seg }
              });
              splitLines.push({ a: seg[0], b: seg[1] });
            });

          }

          if (rule.type === 'of') {
            const pts = buildSidePoints(rule.lhs);
            pts.forEach(p => addPoint(areaCode, p));
            const coords = pts.map(p => p.coord);
            if (coords.length < 2) return;

            const ext = extendPolylineToBorders(coords, ring);
            const clippedSegs = clipPolylineToPolygon(ext, ring);
            clippedSegs.forEach((seg) => {
              lineFeatures.push({
                type: 'Feature',
                properties: { area: areaCode, qnh: rule.qnh, type: 'of', dir: rule.dir || '', idx },
                geometry: { type: 'LineString', coordinates: seg }
              });
              splitLines.push({ a: seg[0], b: seg[1] });
            });

          }
        });

      });

      const lineFC = { type: 'FeatureCollection', features: lineFeatures };
      const pointFC = { type: 'FeatureCollection', features: pointFeatures };
      const labelFC = { type: 'FeatureCollection', features: labelFeatures };
      const zoneLabelFC = { type: 'FeatureCollection', features: [] };
      const zoneFillFC = { type: 'FeatureCollection', features: [] };

      ensureSource('qnh-split-lines', lineFC);
      ensureSource('qnh-split-points', pointFC);
      ensureSource('qnh-split-labels', labelFC);
      ensureSource('qnh-zone-labels', zoneLabelFC);
      ensureSource('qnh-zone-fills', zoneFillFC);

      if (!map.getLayer('qnh-split-lines')) {
        map.addLayer({
          id: 'qnh-split-lines',
          type: 'line',
          source: 'qnh-split-lines',
          paint: {
            'line-color': '#1f9e45',
            'line-width': 3
          }
        });
      }

      if (!map.getLayer('qnh-split-points')) {
        map.addLayer({
          id: 'qnh-split-points',
          type: 'symbol',
          source: 'qnh-split-points',
          layout: {
            'text-field': 'x',
            'text-size': 18,
            'text-allow-overlap': true,
            'symbol-z-order': 'source'
          },
          paint: {
            'text-color': '#000000',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
      }

      if (!map.getLayer('qnh-split-point-labels')) {
        map.addLayer({
          id: 'qnh-split-point-labels',
          type: 'symbol',
          source: 'qnh-split-points',
          layout: {
            'text-field': ['get', 'name'],
            'text-size': 7,
            'text-allow-overlap': true,
            'symbol-z-order': 'source',
            'text-offset': [0.8, 0],
            'text-anchor': 'left'
          },
          paint: {
            'text-color': '#111111',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1
          }
        });
      }

      if (!map.getLayer('qnh-zone-fills')) {
        map.addLayer({
          id: 'qnh-zone-fills',
          type: 'fill',
          source: 'qnh-zone-fills',
          paint: {
            'fill-color': [
              'case',
              ['==', ['get', 'kind'], 'rest'], '#ff4d4d', // REST in red
              '#00a2ff' // others in blue
            ],
            'fill-opacity': 0.25
          }
        });
      }

      if (!map.getLayer('qnh-zone-fills-outline')) {
        map.addLayer({
          id: 'qnh-zone-fills-outline',
          type: 'line',
          source: 'qnh-zone-fills',
          paint: {
            'line-color': '#0044ff',
            'line-width': 3,
            'line-opacity': 0.9
          }
        });
      }

      if (!map.getLayer('qnh-zone-labels')) {
        map.addLayer({
          id: 'qnh-zone-labels',
          type: 'symbol',
          source: 'qnh-zone-labels',
          layout: {
            'text-field': ['to-string', ['get', 'qnh']],
            'text-font': ['Noto Sans Regular'],
            'text-size': 18,
            'text-allow-overlap': true,
            'text-ignore-placement': true,
            'symbol-z-order': 'source'
          },
          paint: {
            'text-color': '#0a7e2f',
            'text-halo-color': '#ffffff',
            'text-halo-width': 2
          }
        });
      }

      if (!zoneClickBound) {
        zoneClickBound = true;
        map.on('click', 'qnh-zone-fills', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['qnh-zone-fills'] });
          if (!features.length) return;
          const f = features[0];
          const fid = f.id;
          if (selectedZoneId !== null) {
            map.setFeatureState({ source: 'qnh-zone-fills', id: selectedZoneId }, { selected: false });
          }
          selectedZoneId = fid;
          map.setFeatureState({ source: 'qnh-zone-fills', id: fid }, { selected: true });
          const props = f.properties || {};
          const name = props.name || `Zone ${fid}`;
          const area = props.area || 'Unknown';
          const qnh = props.qnh || '';
          new maplibregl.Popup({ closeButton: true })
            .setLngLat(e.lngLat)
            .setHTML(`<strong>${name}</strong><br>Area: ${area}<br>QNH: ${qnh}`)
            .addTo(map);
        });
      }

      // persist for diagnostics
      lastZonePolygons = zonePolygons.slice();
      lastZoneLabelCandidates = zoneLabelFeatures.slice();
      lastZoneLabelFeatures = zoneLabelFeatures.slice();

    }

    // Diagnostic: log or highlight any computed zone polygons missing an assigned QNH
    function dumpMissingQnhs() {
      if (!lastZonePolygons || !lastZonePolygons.length) {
        console.info('No zone polygons available yet. Run a QNH fetch to compute split zones.');
        return;
      }

      const missing = [];
      const unlabeled = [];

      const labelPts = (lastZoneLabelFeatures || []).map(f => ({ area: (f.properties && f.properties.area || '').toUpperCase(), qnh: f.properties && f.properties.qnh, coord: f.geometry && f.geometry.coordinates }));

      lastZonePolygons.forEach((pz, idx) => {
        const area = (pz.area || '').toUpperCase();
        const assigned = pz.qnh;
        const poly = pz.poly || pz.polygon || (pz.polygon && pz.polygon.geometry && pz.polygon.geometry.coordinates && pz.polygon.geometry.coordinates[0]);
        if (!assigned) missing.push({ idx, area, polygon: pz });

        const hasLabel = labelPts.some(lp => lp.area === area && lp.qnh === assigned && (() => {
          try { return turf.booleanPointInPolygon(turf.point(lp.coord), turf.polygon([pz.poly || pz.polygon])); } catch (e) { return false; }
        })());
        if (!hasLabel) unlabeled.push({ idx, area, qnh: assigned });
      });

      console.group('Dump Missing QNHs');
      console.log('Total pieces:', lastZonePolygons.length);
      console.log('Pieces with no assigned QNH:', missing.length, missing.map(m => `${m.area}#${m.idx}`));
      console.log('Pieces with assigned QNH but no placed label:', unlabeled.length, unlabeled.map(u => `${u.area}#${u.idx} (${u.qnh || ''})`));

      if (missing.length) console.log('Missing pieces detail:', missing);
      if (unlabeled.length) console.log('Unlabeled pieces detail:', unlabeled);

      const missingFeatures = missing.map(m => ({ type: 'Feature', properties: { area: m.area }, geometry: m.polygon && m.polygon.geometry ? m.polygon.geometry : null }));
      if (map.getSource('qnh-missing-polygons')) {
        map.getSource('qnh-missing-polygons').setData({ type: 'FeatureCollection', features: missingFeatures });
      } else {
        map.addSource('qnh-missing-polygons', { type: 'geojson', data: { type: 'FeatureCollection', features: missingFeatures } });
        map.addLayer({ id: 'qnh-missing-polygons-fill', type: 'fill', source: 'qnh-missing-polygons', paint: { 'fill-color': '#ffdddd', 'fill-opacity': 0.6, 'fill-outline-color': '#ff3333' } });
      }

      console.groupEnd();
      return { missing, unlabeled };
    }

    // Helper used above (small utility) - offset sample point from centroid in given dir
    function offsetFromCentroid(ring, dirVec, distance) {
      const c = polygonCentroid(ring);
      return [c[0] + dirVec[0] * distance, c[1] + dirVec[1] * distance];
    }

    // expose dump helper to console for quick debugging
    window.dumpMissingQnhs = dumpMissingQnhs;

  </script>
</body>
</html>
