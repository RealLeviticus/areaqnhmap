<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Area QNH Map</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/maplibre-gl@3.5.2/dist/maplibre-gl.css"
  />
  <style>
    :root {
      --bg: #ffffff;
      --panel: #f7f7f7;
      --accent: #0066cc;
      --text: #111111;
      --muted: #4f4f55;
      --stroke: #d6d6d6;
      --area-stroke: #d40000;
      --area-fill: rgba(255, 255, 255, 0.35);
      --area-fill-highlight: rgba(255, 230, 230, 0.55);
      --label-red: #c40000;
      --label-blue: #0054a6;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    header {
      padding: 14px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--stroke);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .title h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }

    .title .sub {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .badges { display: none; }

    main {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 16px;
      padding: 16px;
    }

    #map {
      width: 100%;
      height: 72vh;
      min-height: 520px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.18);
      background: #edf1f5; /* light to match base tiles and hide seams */
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.12);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .panel h2 {
      margin: 0 0 4px 0;
      font-size: 1rem;
      color: var(--text);
    }

    .panel p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .legend {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 10px;
      align-items: center;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .legend-swatch {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid var(--stroke);
    }

    .note {
      background: #fff8e1;
      border: 1px dashed #f0c14b;
      color: #8b6b00;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 0.92rem;
    }

    .area-label {
      color: var(--label-red);
      font-weight: 700;
      font-size: 10px;
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);
    }

    @media (max-width: 1024px) {
      main { grid-template-columns: 1fr; }
      #map { height: 64vh; min-height: 420px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Area QNH Map</h1>
      <p class="sub">Replicate of the BOM Area QNH Map which was removed with the new BOM website.</p>
    </div>
    <div class="badges">
      <span class="badge">Static single-page</span>
      <span class="badge">Leaflet overlay</span>
      <span class="badge">Area labels</span>
    </div>
  </header>

  <main>
    <div id="map" aria-label="Area QNH map"></div>

    <section class="panel">
      <h2>How to swap in accurate boundaries</h2>
      <p>Replace <code>data/gaf-areas.geojson</code> with real GAF polygons (WGS84). Each feature should have properties <code>area_code</code> and optional <code>name</code>/<code>qnh</code>. The map reloads data on refresh.</p>
      <div class="legend">
        <span class="legend-swatch" style="background: var(--area-fill);"></span><span>Area boundary</span>
        <span class="legend-swatch" style="background: var(--area-fill-highlight);"></span><span>Highlighted (selected)</span>
      </div>
      <div class="note">Current polygons are placeholders only. Swap with accurate GAF geometry for production use.</div>
    </section>
  </main>

  <script src="https://unpkg.com/maplibre-gl@3.5.2/dist/maplibre-gl.js"></script>
  <script>
    // MapLibre GL map with OSM raster tiles (simple, no seams);
    // Protomaps vector can be added if you supply an API key or pmtiles URL.
    const osmRasterStyle = {
      version: 8,
      glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
      sources: {
        osm: {
          type: 'raster',
          tiles: [
            'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
          ],
          tileSize: 256,
          attribution: '© OpenStreetMap contributors',
        },
      },
      layers: [
        {
          id: 'osm-base',
          type: 'raster',
          source: 'osm',
          minzoom: 0,
          maxzoom: 19,
        }
      ],
    };

    const map = new maplibregl.Map({
      container: 'map',
      style: osmRasterStyle,
      center: [134.5, -25.5],
      zoom: 3.6,
      cooperativeGestures: false, // allow zoom without holding Ctrl
      scrollZoom: true,
      attributionControl: true,
    });
    map.addControl(new maplibregl.NavigationControl({ visualizePitch: false }), 'top-left');

    let activeFeatureId = null;
    let areaGeoJSON = null;
    let airspaceLoaded = false;
    let airspaceReady = new Promise((resolve) => {
      const wait = () => {
        if (window.airspaceData?.airports?.length || window.airspaceData?.waypoints?.length) {
          airspaceLoaded = true;
          resolve();
        } else {
          setTimeout(wait, 200);
        }
      };
      wait();
    });

    map.on('load', () => {
      loadAreas();
      // Kick off QNH fetch loop after map and airspace are ready
      startQNHLoop();
    });

    async function loadAreas() {
      try {
        const res = await fetch('data/gaf-areas.geojson');
        const geojson = await res.json();
        geojson.features.forEach((f, i) => { f.id = i + 1; });
        areaGeoJSON = geojson;

        map.addSource('areas', {
          type: 'geojson',
          data: geojson,
        });

        map.addLayer({
          id: 'areas-fill',
          type: 'fill',
          source: 'areas',
          paint: {
            'fill-color': [
              'case',
              ['boolean', ['feature-state', 'active'], false], '#ffe6e6',
              ['coalesce', ['get', 'color'], '#ffffffcc']
            ],
            'fill-opacity': 0.35,
          }
        });

        map.addLayer({
          id: 'areas-line',
          type: 'line',
          source: 'areas',
          paint: {
            'line-color': '#d40000',
            'line-width': 2,
          }
        });

        map.addLayer({
          id: 'areas-label',
          type: 'symbol',
          source: 'areas',
          layout: {
            'text-field': ['get', 'area_code'],
            'text-font': ['Noto Sans Regular'],
            'text-size': 11,
            'text-allow-overlap': true,
            'text-ignore-placement': true,
            'text-variable-anchor': ['center'],
            'text-justify': 'center',
            'symbol-z-order': 'source',
          },
          paint: {
            'text-color': '#c40000',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1.0,
          }
        });

        fitToAreas(geojson);

        map.on('mousemove', 'areas-fill', (e) => {
          if (!e.features?.length) return;
          map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'areas-fill', () => {
          map.getCanvas().style.cursor = '';
        });

        map.on('click', 'areas-line', (e) => {
          if (!e.features?.length) return;
          const feature = e.features[0];
          setActiveFeature(feature.id);
          const code = feature.properties?.area_code || 'Area';
          const name = feature.properties?.name || '';
          const qnh = feature.properties?.qnh ? `QNH: ${feature.properties.qnh}` : 'QNH: TBD';
          const title = [code, name].filter(Boolean).join(' · ');
          new maplibregl.Popup({ closeOnMove: true })
            .setLngLat(e.lngLat)
            .setHTML(`<strong>${title}</strong><br/>${qnh}`)
            .addTo(map);
        });
      } catch (err) {
        console.error('Failed to load GeoJSON', err);
      }
    }

    // --- QNH fetching & route drawing ---
    const BOM_QNH_URL = 'https://www.bom.gov.au/aviation/forecasts/area-qnh/';
    let qnhGeoJSON = { type: 'FeatureCollection', features: [] };

    function startQNHLoop() {
      fetchAndDrawQNH();
      setInterval(fetchAndDrawQNH, 15 * 60 * 1000);
    }

    async function fetchAndDrawQNH() {
      await airspaceReady;
      try {
        const res = await fetch(BOM_QNH_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const html = await res.text();
        const text = html.replace(/<[^>]+>/g, '\n');
        const routes = parseQNHText(text);
        qnhGeoJSON = {
          type: 'FeatureCollection',
          features: routes
            .filter(r => r.coords.length >= 2)
            .map((r, i) => ({
              type: 'Feature',
              id: i + 1,
              properties: { qnh: r.qnh, label: r.qnh?.toString() || '' },
              geometry: { type: 'LineString', coordinates: r.coords }
            }))
        };
        upsertQnhLayers();
      } catch (err) {
        console.error('Failed to fetch/parse QNH', err);
      }
    }

    function upsertQnhLayers() {
      if (!map.getSource('qnh-routes')) {
        map.addSource('qnh-routes', { type: 'geojson', data: qnhGeoJSON });
        map.addLayer({
          id: 'qnh-routes-line',
          type: 'line',
          source: 'qnh-routes',
          paint: {
            'line-color': '#1c8a2c',
            'line-width': 2.5,
          }
        });
        map.addLayer({
          id: 'qnh-routes-label',
          type: 'symbol',
          source: 'qnh-routes',
          layout: {
            'text-field': ['get', 'label'],
            'text-font': ['Noto Sans Regular'],
            'text-size': 11,
            'text-allow-overlap': true,
            'text-ignore-placement': true,
            'symbol-placement': 'line',
            'symbol-spacing': 250,
          },
          paint: {
            'text-color': '#1c8a2c',
            'text-halo-color': '#ffffff',
            'text-halo-width': 1.0,
          }
        });
      } else {
        map.getSource('qnh-routes').setData(qnhGeoJSON);
      }
    }

    function parseQNHText(text) {
      const lines = text.split(/\n+/).map(l => l.trim()).filter(Boolean);
      const routes = [];
      const areaRe = /AREA\s*-?\s*(\d+)/i;
      lines.forEach((line) => {
        const areaMatch = line.match(areaRe);
        if (!areaMatch) return;
        const areaCode = `AREA-${areaMatch[1]}`;
        // Split segments by commas
        const segments = line.split(',').map(s => s.trim());
        segments.forEach(seg => {
          const m = seg.match(/([A-Z0-9\/\s]+)\s+(\d{3,4})/);
          if (!m) return;
          const routeStr = m[1].trim();
          const qnh = Number(m[2]);
          const ids = (routeStr.match(/[A-Z]{3,5}/g) || []).map(s => s.trim());
          const coords = ids
            .map(id => lookupCoord(id))
            .filter(Boolean);
          if (coords.length >= 2) {
            routes.push({ area: areaCode, qnh, coords });
          }
        });
      });
      return routes;
    }

    function lookupCoord(id) {
      if (!window.airspaceData) return null;
      const { airports = [], waypoints = [] } = window.airspaceData;
      const hit = airports.find(a => a.id === id || a.name === id) || waypoints.find(w => w.id === id || w.name === id);
      return hit ? [hit.lon, hit.lat] : null;
    }

    function setActiveFeature(id) {
      if (activeFeatureId !== null) {
        map.setFeatureState({ source: 'areas', id: activeFeatureId }, { active: false });
      }
      activeFeatureId = id;
      if (id !== null && id !== undefined) {
        map.setFeatureState({ source: 'areas', id }, { active: true });
      }
    }

    function clearHoverStates() {
      const source = map.getSource('areas');
      if (!source || !source._data?.features) return;
      source._data.features.forEach((f) => {
        if (f.id !== undefined) {
          map.setFeatureState({ source: 'areas', id: f.id }, { hover: false });
        }
      });
    }

    function fitToAreas(geojson) {
      const bounds = getGeoJsonBounds(geojson);
      if (bounds) {
        map.fitBounds(bounds, { padding: 40, maxZoom: 6 });
      }
    }

    function getGeoJsonBounds(geojson) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      const update = (coord) => {
        const [x, y] = coord;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      };
      const walk = (coords) => {
        if (typeof coords[0] === 'number') {
          update(coords);
        } else {
          coords.forEach(walk);
        }
      };
      if (!geojson?.features) return null;
      geojson.features.forEach((f) => {
        if (f.geometry?.coordinates) walk(f.geometry.coordinates);
      });
      if (!Number.isFinite(minX)) return null;
      return [[minX, minY], [maxX, maxY]];
    }


    // --- Airspace data (airports + waypoints), cached monthly ---
    const AIRSPACE_URL = 'https://raw.githubusercontent.com/vatSys/australia-dataset/master/Airspace.xml';
    const AIRSPACE_CACHE_KEY = 'airspace-cache-v1';
    const AIRSPACE_CACHE_DATE_KEY = 'airspace-cache-date-v1';
    window.airspaceData = { airports: [], waypoints: [] };

    loadAirspaceData();

    async function loadAirspaceData() {
      const today = new Date();
      const isFirstOfMonth = today.getDate() === 1;
      const cachedDateStr = localStorage.getItem(AIRSPACE_CACHE_DATE_KEY);
      const cachedPayload = localStorage.getItem(AIRSPACE_CACHE_KEY);
      let useCache = false;

      if (cachedDateStr && cachedPayload) {
        const cachedDate = new Date(cachedDateStr);
        const sameMonth = cachedDate.getFullYear() === today.getFullYear() && cachedDate.getMonth() === today.getMonth();
        useCache = sameMonth && !isFirstOfMonth; // refresh on the 1st
      }

      if (useCache) {
        try {
          const parsed = JSON.parse(cachedPayload);
          if (parsed?.airports && parsed?.waypoints) {
            window.airspaceData = parsed;
            console.info(`Airspace (cached): ${parsed.airports.length} airports, ${parsed.waypoints.length} waypoints`);
            return;
          }
        } catch (e) {
          // fall through to fetch
        }
      }

      try {
        const res = await fetch(AIRSPACE_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const xmlText = await res.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, 'text/xml');

        const airports = [];
        xml.querySelectorAll('Airport').forEach((node) => {
          const name = node.getAttribute('Name') || node.getAttribute('ICAO') || node.getAttribute('IATA');
          const id = node.getAttribute('ICAO') || node.getAttribute('IATA') || name;
          const lat = parseFloat(node.getAttribute('Lat'));
          const lon = parseFloat(node.getAttribute('Lon')) || parseFloat(node.getAttribute('Long'));
          if (Number.isFinite(lat) && Number.isFinite(lon) && id) {
            airports.push({ id, name: name || id, lat, lon, type: 'airport' });
          }
        });

        const waypoints = [];
        xml.querySelectorAll('Waypoint').forEach((node) => {
          const id = node.getAttribute('Name') || node.getAttribute('ID') || node.getAttribute('Ident');
          const lat = parseFloat(node.getAttribute('Lat'));
          const lon = parseFloat(node.getAttribute('Lon')) || parseFloat(node.getAttribute('Long'));
          if (Number.isFinite(lat) && Number.isFinite(lon) && id) {
            waypoints.push({ id, name: id, lat, lon, type: 'waypoint' });
          }
        });

        window.airspaceData = { airports, waypoints };
        localStorage.setItem(AIRSPACE_CACHE_KEY, JSON.stringify(window.airspaceData));
        localStorage.setItem(AIRSPACE_CACHE_DATE_KEY, today.toISOString());
        console.info(`Airspace loaded fresh: ${airports.length} airports, ${waypoints.length} waypoints`);
      } catch (err) {
        console.error('Failed to load airspace data', err);
      }
    }

    // Example hook for live QNH updates (MapLibre):
    // updateQNHData({ 'AREA-10': { qnh: '1012', color: '#ffb703' } });
    function updateQNHData(qnhByAreaCode) {
      if (!areaGeoJSON) return;
      let changed = false;
      areaGeoJSON.features.forEach((f) => {
        const code = f.properties?.area_code;
        if (!code) return;
        const data = qnhByAreaCode[code];
        if (!data) return;
        if (data.qnh) {
          f.properties.qnh = data.qnh;
          changed = true;
        }
        if (data.color) {
          f.properties.color = data.color;
          changed = true;
        }
      });
      if (changed) {
        const src = map.getSource('areas');
        if (src) src.setData(areaGeoJSON);
      }
    }
  </script>
</body>
</html>
