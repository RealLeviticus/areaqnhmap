name: Generate QNH Screenshots

on:
  # Run every 5 minutes
  schedule:
    - cron: '*/5 * * * *'
  
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      force:
        description: 'Force regeneration even if data unchanged'
        type: boolean
        default: false

jobs:
  generate-screenshots:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm install puppeteer

      - name: Check for QNH data changes
        id: check-changes
        run: |
          # Fetch current QNH data
          CURRENT_ISSUED=$(curl -s 'https://areaqnh.therealleviticus.workers.dev/' | grep -oP 'Issued:\s*\K[^<\n]+' | head -1 || echo "")
          
          # Get last known issued from cache
          LAST_ISSUED=""
          if [ -f ".qnh-cache/last_issued.txt" ]; then
            LAST_ISSUED=$(cat .qnh-cache/last_issued.txt)
          fi
          
          echo "Current: $CURRENT_ISSUED"
          echo "Last: $LAST_ISSUED"
          
          if [ "$CURRENT_ISSUED" = "$LAST_ISSUED" ] && [ "${{ github.event.inputs.force }}" != "true" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No change detected, skipping generation"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Change detected or force regeneration requested"
            
            # Save new timestamp
            mkdir -p .qnh-cache
            echo "$CURRENT_ISSUED" > .qnh-cache/last_issued.txt
          fi

      - name: Generate screenshots
        if: steps.check-changes.outputs.changed == 'true'
        run: |
          node << 'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs');
          const path = require('path');

          const MAP_URL = 'https://areaqnh.actuallyleviticus.xyz/index.html';
          const OUTPUT_DIR = './screenshots';

          const REGIONS = {
            'au': { bounds: [[110, -45], [163, -9]], name: 'Australia' },
            'ne': { bounds: [[138, -30], [163, -9]], name: 'Northeast' },
            'se': { bounds: [[138, -45], [163, -30]], name: 'Southeast' },
            'nw': { bounds: [[110, -30], [138, -9]], name: 'Northwest' },
            'sw': { bounds: [[110, -45], [138, -30]], name: 'Southwest' },
          };

          async function captureScreenshot(page, regionCode, config) {
            console.log(`Capturing ${regionCode} (${config.name})...`);
            
            // Navigate to map
            await page.goto(MAP_URL, { waitUntil: 'networkidle0', timeout: 60000 });
            
            // Wait for map to load
            await page.waitForFunction(() => {
              return window.map && window.map.loaded && window.map.loaded();
            }, { timeout: 30000 });
            
            // Wait extra for tiles
            await new Promise(r => setTimeout(r, 3000));
            
            // Zoom to region
            await page.evaluate((bounds) => {
              if (window.map && window.map.fitBounds) {
                const mapBounds = new maplibregl.LngLatBounds(bounds[0], bounds[1]);
                window.map.fitBounds(mapBounds, { padding: 10, duration: 0 });
              }
            }, config.bounds);
            
            // Wait for zoom and tiles
            await new Promise(r => setTimeout(r, 2000));
            await page.waitForFunction(() => window.map && !window.map.isMoving(), { timeout: 10000 });
            await new Promise(r => setTimeout(r, 1000));
            
            // Take screenshot of map element
            const mapElement = await page.$('#map');
            const filename = `qnh-${regionCode}.png`;
            await mapElement.screenshot({ path: path.join(OUTPUT_DIR, filename), type: 'png' });
            
            console.log(`âœ“ Saved ${filename}`);
            return filename;
          }

          async function main() {
            // Ensure output directory exists
            if (!fs.existsSync(OUTPUT_DIR)) {
              fs.mkdirSync(OUTPUT_DIR, { recursive: true });
            }

            const browser = await puppeteer.launch({
              headless: 'new',
              args: ['--no-sandbox', '--disable-setuid-sandbox']
            });

            try {
              const page = await browser.newPage();
              await page.setViewport({ width: 1200, height: 900, deviceScaleFactor: 2 });

              for (const [code, config] of Object.entries(REGIONS)) {
                try {
                  await captureScreenshot(page, code, config);
                } catch (error) {
                  console.error(`Failed to capture ${code}:`, error.message);
                }
              }
            } finally {
              await browser.close();
            }
            
            console.log('Screenshot generation complete!');
          }

          main().catch(console.error);
          EOF

      - name: Upload to R2
        if: steps.check-changes.outputs.changed == 'true'
        env:
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
        run: |
          # Install AWS CLI (works with R2)
          pip install awscli
          
          # Configure AWS CLI for R2
          aws configure set aws_access_key_id $R2_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $R2_SECRET_ACCESS_KEY
          aws configure set region auto
          
          # Upload each screenshot
          for file in ./screenshots/*.png; do
            filename=$(basename "$file")
            echo "Uploading $filename..."
            aws s3 cp "$file" "s3://$R2_BUCKET/$filename" \
              --endpoint-url "$R2_ENDPOINT" \
              --content-type "image/png"
          done
          
          echo "All screenshots uploaded to R2!"

      - name: Cache last issued timestamp
        if: steps.check-changes.outputs.changed == 'true'
        uses: actions/cache/save@v3
        with:
          path: .qnh-cache
          key: qnh-issued-${{ github.run_id }}
          
      - name: Restore cache
        uses: actions/cache/restore@v3
        with:
          path: .qnh-cache
          key: qnh-issued-
          restore-keys: qnh-issued-