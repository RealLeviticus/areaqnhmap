name: Generate QNH Screenshots

on:
  schedule:
    - cron: "0 * * * *"  # Every hour on the hour

  workflow_dispatch:
    inputs:
      force:
        description: "Force regeneration even if data unchanged"
        type: boolean
        default: false

permissions:
  contents: write

concurrency:
  group: qnh-screenshots
  cancel-in-progress: false

jobs:
  generate-screenshots:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Node dependencies
        run: |
          npm install puppeteer

      - name: Install system deps for Chromium and WebGL (Ubuntu 24.04 safe)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            xvfb \
            libgbm1 \
            libnss3 \
            libxss1 \
            libatk-bridge2.0-0 \
            libgtk-3-0 \
            libxkbcommon0 \
            libdrm2 \
            libgl1 \
            libgl1-mesa-dri \
            mesa-utils

          sudo apt-get install -y libasound2t64 || sudo apt-get install -y libasound2

      - name: Check for QNH data changes
        id: check-changes
        shell: bash
        run: |
          set -e

          mkdir -p .qnh-cache

          CURRENT_ISSUED=$(curl -s 'https://areaqnh.therealleviticus.workers.dev/' | grep -oP 'Issued:\s*\K[^<\n]+' | head -1 || true)

          LAST_ISSUED=""
          if [ -f ".qnh-cache/last_issued.txt" ]; then
            LAST_ISSUED=$(cat .qnh-cache/last_issued.txt)
          fi

          echo "Current: $CURRENT_ISSUED"
          echo "Last:    $LAST_ISSUED"

          if [ -z "$CURRENT_ISSUED" ]; then
            echo "Could not read Issued timestamp, forcing generation to avoid stale images"
            echo "changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$CURRENT_ISSUED" = "$LAST_ISSUED" ] && [ "${{ github.event.inputs.force }}" != "true" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No change detected, skipping generation"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Change detected or force regeneration requested"
            echo "$CURRENT_ISSUED" > .qnh-cache/last_issued.txt
          fi

      - name: Generate screenshots (Puppeteer + Xvfb + SwiftShader)
        if: steps.check-changes.outputs.changed == 'true'
        env:
          DISPLAY: ":99"
          LIBGL_ALWAYS_SOFTWARE: "1"
          MOZ_DISABLE_RDD_SANDBOX: "1"
        shell: bash
        run: |
          set -e

          Xvfb :99 -screen 0 1920x1080x24 > /dev/null 2>&1 &
          sleep 1

          node << 'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs');
          const path = require('path');

          const MAP_URL = 'https://areaqnh.actuallyleviticus.xyz/index.html?capture=1';
          const OUTPUT_DIR = './screenshots';

          // Regions configured to match BOM output style
          // Bounds: [[minLon, minLat], [maxLon, maxLat]]
          const REGIONS = {
            au: { 
              bounds: [[112, -44], [154, -10]], 
              name: 'Australia',
              width: 800,
              height: 900
            },
            wa: { 
              bounds: [[112, -36], [138, -13]], 
              name: 'Western Australia',
              width: 800,
              height: 900
            },
            se: { 
              bounds: [[134, -44], [154, -28]], 
              name: 'Southeast Australia',
              width: 800,
              height: 900
            },
            ne: { 
              bounds: [[137, -30], [156, -10]], 
              name: 'Northeast Australia',
              width: 800,
              height: 900
            },
          };

          const sleep = (ms) => new Promise(r => setTimeout(r, ms));

          async function main() {
            if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR, { recursive: true });

            const browser = await puppeteer.launch({
              headless: false,
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--enable-webgl',
                '--ignore-gpu-blocklist',
                '--use-gl=angle',
                '--use-angle=swiftshader',
                '--enable-unsafe-swiftshader',
                '--disable-gpu-sandbox',
                '--disable-features=Vulkan',
                '--disable-features=UseSkiaRenderer',
              ]
            });

            try {
              const page = await browser.newPage();
              page.setDefaultTimeout(120000);

              page.on('console', msg => console.log('[PAGE]', msg.text()));
              page.on('pageerror', err => console.log('[PAGE ERROR]', err.message));
              page.on('requestfailed', req => console.log('[REQ FAIL]', req.url(), req.failure()?.errorText));
              page.on('response', res => {
                if (res.status() >= 400) console.log(`[HTTP ${res.status()}] ${res.url()}`);
              });

              await page.evaluateOnNewDocument(() => {
                let internal;
                Object.defineProperty(window, 'maplibregl', {
                  configurable: true,
                  get() { return internal; },
                  set(v) {
                    internal = v;
                    try {
                      const OrigMap = v.Map;
                      class PatchedMap extends OrigMap {
                        constructor(...args) {
                          super(...args);
                          window.__map = this;
                        }
                      }
                      Object.setPrototypeOf(PatchedMap, OrigMap);
                      v.Map = PatchedMap;
                    } catch (e) {}
                  }
                });
              });

              console.log('Loading map page...');
              await page.goto(MAP_URL, { waitUntil: 'networkidle2', timeout: 120000 });

              await page.waitForSelector('#map', { timeout: 120000 });
              await page.waitForFunction(() => window.__map && typeof window.__map.loaded === 'function', { timeout: 120000 });
              await page.waitForFunction(() => window.__map.loaded(), { timeout: 120000 });
              await page.waitForSelector('#map canvas', { timeout: 120000 });

              await page.evaluate(() => {
                const m = window.__map;
                if (!m) return;
                m.setBearing(0);
                m.setPitch(0);
                const style = m.getStyle();
                const layers = style && style.layers ? style.layers : [];
                for (const layer of layers) {
                  if (layer.type === 'symbol') {
                    try { m.setLayoutProperty(layer.id, 'text-allow-overlap', true); } catch (e) {}
                    try { m.setLayoutProperty(layer.id, 'icon-allow-overlap', true); } catch (e) {}
                  }
                }
              });

              const waitForIdle = async () => {
                await page.evaluate(() => new Promise(resolve => {
                  const m = window.__map;
                  if (!m) return resolve();
                  m.once('idle', () => resolve());
                }));
              };

              for (const [code, cfg] of Object.entries(REGIONS)) {
                console.log(`Capturing ${code} (${cfg.name})...`);

                // Set viewport to match this region's dimensions
                await page.setViewport({ 
                  width: cfg.width, 
                  height: cfg.height, 
                  deviceScaleFactor: 2 
                });

                // Resize the map and fit bounds
                await page.evaluate((bounds) => {
                  const m = window.__map;
                  if (!m) return;
                  m.resize();
                  const b = new window.maplibregl.LngLatBounds(bounds[0], bounds[1]);
                  m.fitBounds(b, { padding: 60, duration: 0 });
                }, cfg.bounds);

                await waitForIdle();
                await sleep(1500);

                const mapEl = await page.$('#map');
                const filename = `qnh-${code}.png`;
                await mapEl.screenshot({ path: path.join(OUTPUT_DIR, filename), type: 'png' });

                console.log(`Saved ${filename}`);
              }

              console.log('Screenshot generation complete!');
            } finally {
              await browser.close();
            }
          }

          main().catch(err => {
            console.error('Screenshot generation failed:', err);
            process.exit(1);
          });
          EOF

      - name: Upload to R2
        if: steps.check-changes.outputs.changed == 'true'
        env:
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
        shell: bash
        run: |
          set -e
          pip install awscli

          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set region auto

          shopt -s nullglob
          for file in ./screenshots/*.png; do
            filename=$(basename "$file")
            echo "Uploading $filename..."
            aws s3 cp "$file" "s3://$R2_BUCKET/$filename" \
              --endpoint-url "$R2_ENDPOINT" \
              --content-type "image/png"
          done

          echo "All screenshots uploaded to R2"

      - name: Commit updated issued timestamp
        if: steps.check-changes.outputs.changed == 'true'
        shell: bash
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .qnh-cache/last_issued.txt
          git commit -m "Update QNH issued cache" || echo "No cache changes to commit"
          git push